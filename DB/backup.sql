-- MariaDB dump 10.19-11.2.2-MariaDB, for debian-linux-gnu (x86_64)
--
-- Host: localhost    Database: skw
-- ------------------------------------------------------
-- Server version       11.2.2-MariaDB-1:11.2.2+maria~ubu2204

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `comment`
--

DROP TABLE IF EXISTS `comment`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `comment` (
                           `id` bigint(20) NOT NULL AUTO_INCREMENT,
                           `user_id` bigint(20) DEFAULT NULL,
                           `created_at` varchar(255) DEFAULT NULL,
                           `description` varchar(255) DEFAULT NULL,
                           PRIMARY KEY (`id`),
                           KEY `FK8kcum44fvpupyw6f5baccx25c` (`user_id`),
                           CONSTRAINT `FK8kcum44fvpupyw6f5baccx25c` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `comment`
--

LOCK TABLES `comment` WRITE;
/*!40000 ALTER TABLE `comment` DISABLE KEYS */;
INSERT INTO `comment` VALUES
    (1,1,'2024-02-05 17시 16분 39초','☃️');
/*!40000 ALTER TABLE `comment` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `note`
--

DROP TABLE IF EXISTS `note`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `note` (
                        `id` bigint(20) NOT NULL AUTO_INCREMENT,
                        `category` varchar(255) DEFAULT NULL,
                        `title` varchar(255) DEFAULT NULL,
                        `content` text DEFAULT NULL,
                        PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=21 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `note`
--

LOCK TABLES `note` WRITE;
/*!40000 ALTER TABLE `note` DISABLE KEYS */;
INSERT INTO `note` VALUES
                       (2,'HTML & CSS','HTML & CSS 기초','## 📘 많이쓰는 HTML태그 정리! 📚\n\n`<div>` : 영역을 나누는데 쓰임\n\n`<p>` : 문단을 나누는데 쓰임 (div태그와 거의 비슷한 용도이나 단지 밑에 공간이 좀더 생김)\n\n`<img>` : 이미지 넣는데 쓰임. 단일태그임\n\n`<input>` : 검색창처럼 사용자에게 입력을 받는 태그 단일태그임\n\n`<button>` : 버튼을 만듬\n\n`<a>` : 링크를 연결해서 여러페이지로 이동할수있음 \n\n<br>\n\n> head 태그 안에 있던 태그들 정리 🚀\n\n`<meta>` : 웹서버와 웹브라우저 사이에 주고받는 정보를 정의하는데 사용됨 문서 자체의 특성을 나타냄\n\n`<title>` : 웹사이트가 열리면 상단에 생기는 tab에 이름을 나타냄\n\n`<link>` : 필요한 스타일이나 아이콘등 외부 문서를 html문서에 연결시키는데 사용됨\n\n---\n\n## 기본적인 CSS 정리! 📚\n\n`color` : 텍스트의 색을 바꿈\n\n`background-color` : 배경색을 바꿈\n\n`border` : 테두리를 그려줌, 3개의 인자를 받음 (두께, 스타일, 색깔)\n\n`width / height` : 넓이와 높이를 지정하는데 쓰임\n\n`text-align` : 정렬 (left, center, right)\n\n`margin` : 내 영역 밖에 공간을 줌 (top, left, right, bottom)\n\n`padding` : 내 영역 안에서 공간을 줌 (top, left, right, bottom)\n\n---\n\n## 📘 HTML태그에 스타일을주는 방법 🔗\n\n<br>\n\n### 1. HTML 태그에 직접주는 방법\n- 어떤 태그에 공통적인 스타일을 주고싶을 때 사용하는 방법\n\n```css\n   div {\n         color:red;\n   }\n```\n\n<br>\n\n### 2. id 를 이용해 주는방법\n- class 와 사용방식이 비슷하지만 한번에 하나의 스타일만 줄수있음, 주로 자바스크립트에서 많이 쓰이고 스타일링에는 많이 안쓰이는 방식\n\n```css\n#new-style {\ncolor:red;\n}\n```\n\n```html\n<div id=\"new-style\">\n```\n\n<br>\n\n### 3. class를 이용해 주는 방법 (강의에서 사용된 방법)\n- 한번에 여러개의스타일을 줄수있다. 제일 많이 쓰이는 방법\n\n```css\n.new-style {\ncolor:red;\n}\n```\n\n```html\n<div class=\"new-style\">\n```\n\n<br>\n\n### 4. 복합 선택자\n- **일치 선택자** : 두가지 조건을 동시에 만족하는 요소 선택\n\n```css\ndiv.new-style {\n      /*div태그에 new-style클래스\n}\n```\n\n<br>\n\n**자식 선택자**\n```css\ndiv>.new-style {\n/* div의 자식요소중 class=\"new-style\"선택\n}\n```\n\n**후손 선택자**\n```css\ndiv .new-style {\n/* div 후손요소들 중에서 class=\"new-style\"\n}\n```'),
                       (3,'HTML & CSS','Wire Frame 구조 잡기','## 📘 WireFrame\n\n> 🚩 **WireFrame이란?\n\n웹 or 앱의 인터페이스를 시각적으로 묘사한것, 어떤 목적을 가진 프로그램인지 알 수 있게 설계하는것이 중요함.\n\n<br>\n\n> 🚩 **Mock-up**\n\n**웹 or 앱 에서의 목업은 기능적으로는 동작하지 않지만, 실제 제품이 작동하는 모습과 동일하게 HTML,CSS 작성하는것**\n\n<br>\n\n> 🚩 **HTML로 웹 앱 구조잡기**\n\n**1. 큰틀에서 영역 나누기**\n\n- r , w 영역 나누기\n- 태그별로 영역 나누기\n\n<br>\n\n**댓글 입력창**\n\n![img](https://raw.githubusercontent.com/spacedustz/Obsidian-Image-Server/main/img/wireframe1.png)\n\n<br>\n\n**댓글창**\n\n![img](https://raw.githubusercontent.com/spacedustz/Obsidian-Image-Server/main/img/wireframe2.png)\n\n<br>\n\n**위에서 간단하게만 태그별로 영역을 나눴는데 id와 class를 이용해서 목적에 맞게 사용**\n\n목적에 맞는 id & class를 영역별로 나뉜 태그에 지정\n\n![img](https://raw.githubusercontent.com/spacedustz/Obsidian-Image-Server/main/img/wireframe3.png)\n\n<br>\n\n이후 CSS 파일에서 각 태그 id & class에 대한 style을 지정 해주면 됨\n\n![img](https://raw.githubusercontent.com/spacedustz/Obsidian-Image-Server/main/img/wireframe4.png) '),
                       (4,'HTML & CSS','Flex Box 란?','## 📘 Flex Box\n\n**https://flexboxfroggy.com/#ko <- Practice Flexbox**\n\n<br>\n\n> 🚩 **레이아웃 구성**\n\n- 수직분할 : 화면을 수직으로 구분하여, 콘텐츠가 가로로 배치될 수 있도록 요소를 배치\n- 수평분할 : 분할된 각각의 요소를 수평으로 구분하여, 내부 콘텐츠가 세로로 배치될 수 있도록 요소 배치\n- CSS로 화면을 구분할때에는 수직분할과 수평분할을 차례로 적용함.\n\n<br>\n\n**VS Code의 기본 레이아웃을 HTML 형식으로 작성한 예시**\n\n![img](https://raw.githubusercontent.com/spacedustz/Obsidian-Image-Server/main/img/flexbox1.png)\n\n<br>\n\nHTML에서 class 로 지정된 요소를 CSS로 구현\n\n![img](https://raw.githubusercontent.com/spacedustz/Obsidian-Image-Server/main/img/flexbox2.png)\n\n<br>\n\n클래스이름:구현 을 1:1로 일치시키는 기법을 [Atomic CSS 방법론](https://www.sitepoint.com/css-architecture-block-element-modifier-bem-atomic-css/) 이라고함.\n\n<br>\n\n> 🚩 **레이아웃 리셋**\n\n문서의 시작점을 정확히 (0,0) 으로 시작하고 싶은데,\n\nHTML의 기본 문서 스타일이 다르게 설정되있을 경우\n\n<br>\n\n기본 HTML 스타일을 제거하는 CSS 코드 예시\n\n![img](https://raw.githubusercontent.com/spacedustz/Obsidian-Image-Server/main/img/flexbox3.png)\n\n------\n## 📘 FlexBox로 레이아웃 잡기\n\n<br>\n\n> 🚩 **Flexbox를 사용 하는 이유**\n\nFlexbox는 모던 웹을 위하여 제안된 CSS3의 새로운 layout 방식이다.\n\n요소의 사이즈가 불명확하거나 동적으로 변화할 때에도 유연한 레이아웃을 실현할 수 있다.\n\n복잡한 레이아웃이라도 적은 코드로 보다 간단하게 표현할 수 있다.\n\n<br>\n\n> 🚩 **Flexbox 기본 개념**\n\nFlexbox를 설명하는 가장 기본적인 개념은**Flex-container(부모)/Flex-item(자식)에서부터 시작한다.**\n\nFlexbox의 **중요한 특징**은 아이템 각각에다가 명령을 하는 것이 아니라, **부모**한테 명령하는 것이다.\n\n\nflex-container(부모)에게 display:flex를 선언하게 되면 flex-items은 즉각적으로 영향을 받고 실행된다.\n\n하지만 여기서 유의해야할 건, Flex-container와 flex-items가 **직접적으로 종속관계**에 있어야 Flex모드가 제대로 적용된다.\n\n초보단계에서 가장 많이 하는 실수중에 하나가 바로 이 부분.\n\n<br>\n\n> 🚩 **display:flex 분석**\n\n부모 박스에 적용하여 자식박스의 방향과 크기를 결정하는 레이아웃 구성 방법 예시\n\n우선 HTML로 3개의 div요소를 가진 main 작성\n\n![img](https://raw.githubusercontent.com/spacedustz/Obsidian-Image-Server/main/img/flexbox4.png)\n\n<br>\n\n각 요소들이 잘 보이도록 main에 빨간색 점선, div에 초록색 실선으로 테두리를 설정하고 전체적으로 margin과 padding을 10px씩 할당\n\n![img](https://raw.githubusercontent.com/spacedustz/Obsidian-Image-Server/main/img/flexbox5.png)\n\n<br>\n\n결과값. div 요소는 따로 설정을 안해주면 위쪽에서부터 세로로 정렬되며, 가로로 넓은 공간을 차지함\n\n![img](https://raw.githubusercontent.com/spacedustz/Obsidian-Image-Server/main/img/flexbox6.png)\n\n<br>\n\nmain에 display: flex 를 추가해보자\n\n![img](https://raw.githubusercontent.com/spacedustz/Obsidian-Image-Server/main/img/flexbox7.png)\n\n<br>\n\ndisplay를 적용했더니 div 요소들이 왼쪽부터 가로로 정렬된 것과 내용만큼의 공간을 차지하는것을 알 수 있음\n\n![img](https://raw.githubusercontent.com/spacedustz/Obsidian-Image-Server/main/img/flexbox8.png)\n\n<br>\n\n> 🚩 **Parent 요소에 적용해야하는 Flexbox 속성들**\n\n**주의점**\n\n- 속성을 지정해주는 위치를 주의해야함\n- Flexbox 속성중 부모요소,자식요소에 적용해야 하는 속성들이 있음.\n- 위치가 맞지 않으면 요소들이 원하는대로 정렬이 되지 않음.\n\n<br>\n\nAxis (축): Main-axis(기준축) / Corss-axis(교차축)\nDefault flex-direction(Main-asis) = row\n\n<br>\n\n**flex-direction: row-reverse**\n기준축이 가로 정렬, 교차축이 세로정렬이되 아이템의 정렬순서가 뒤바뀐다.\nflex-start와 flex-end의 방향도 반대로 돌려진다.\n\n<br>\n\n**flex-direction: column-reverse**\n기준축이 세로 정렬, 교차축이 가로정렬이되 아이템의 정렬 순서가 뒤바뀐다.\n마찬가지로 flex-start와 flex-end의 방향도 반대로 돌려진다.\n\n<br>\n\nflex-direction을 row-reverse로 설정했을때\n\n![img](https://raw.githubusercontent.com/spacedustz/Obsidian-Image-Server/main/img/flexbox9.png)\n\n<br>\n\n정렬 기준축이 반대방향으로 바뀐걸 볼 수 있다\n\n![img](https://raw.githubusercontent.com/spacedustz/Obsidian-Image-Server/main/img/flexbox10.png)\n\n\n**justify-content : 기준축의 정렬관리 (default: item을 수평정렬)**\n\n**align-items : 교차축의 정렬관리 (default: item을 수직정렬)**\n\n<br>\n\n**Flexbox에서 가장 많이 사용되는 정렬방식 중 하나는 요소들을 일정한 간격을 두고 양 끝 배치하는것임**\n\njustify-content: space-between 설정\n\n![img](https://raw.githubusercontent.com/spacedustz/Obsidian-Image-Server/main/img/flexbox11.png)\n\n<br>\n\n일정한 간격을 두고 정렬되는것을 볼 수 있다\n\n![img](https://raw.githubusercontent.com/spacedustz/Obsidian-Image-Server/main/img/flexbox12.png)\n\n<br>\n\n**그렇다면 flex-direction 을 column으로 변경해도 똑같이 적용이 될까?**\n\nflex-direction을 column으로 설정한 모습\n\n![img](https://raw.githubusercontent.com/spacedustz/Obsidian-Image-Server/main/img/flexbox13.png)\n\n<br>\n\n축 방향은 전환이 되었지만 양 끝으로 배치되지는 않았다. 그 이유는 정렬이 될만큼 충분한 사이즈의 세로값 입력이 없었기 때문\n\n![img](https://raw.githubusercontent.com/spacedustz/Obsidian-Image-Server/main/img/flexbox14.png)\n\n<br>\n\nFlex를 선언한 부모태그에 세로값을 적용 시켜보자. (height= 50vh)\n\n![img](https://raw.githubusercontent.com/spacedustz/Obsidian-Image-Server/main/img/flexbox15.png)\n\n\n\n부모태그에 height를 설정해주니 정상적으로 justify-content:space-between 항목이 적용이 된 모습\n\n![img](https://raw.githubusercontent.com/spacedustz/Obsidian-Image-Server/main/img/flexbox16.png)\n\n<br>\n\n> 🚩 **align-self**\n\nalign-self는 flexbox에서 몇 안되게 존재하는 독특한 개념인데 flex-container에게 옵션을 주는게 아니라\n\n아이템에게 직접 옵션을 준다는 특징이 있다.\n\n<br>\n\n**align-self**는 align이 의미하듯이 교차축에 대한 정렬을 다루는데,\n\n**각각의 아이템에 대한 정렬을 조절**할 수 있다.\n\n<br>\n\nHTML 파일에서 class를 skw로 지정하고 CSS에서 first-child 에게만 align-self를 적용시켜봤다\n\n![img](https://raw.githubusercontent.com/spacedustz/Obsidian-Image-Server/main/img/flexbox17.png)\n\n<br>\n\nfirst-child 인 box1만 align-self: flex-end 의 적용을 받은 모습\n\n![img](https://raw.githubusercontent.com/spacedustz/Obsidian-Image-Server/main/img/flexbox18.png)\n\n<br>\n\n> 🚩 **flex-wrap (줄바꿈 설정)**\n\n- 하위요소의 크기가 상위요소의 크기를 넘으면 자동 줄 바꿈을 할 것인지 설정.\n- 설정해주지 않으면 줄바꿈 X\n\n<br>\n\n상위요소인 main에 작성하여 하위요소인 div의 줄바꿈 설정\n\n![img](https://raw.githubusercontent.com/spacedustz/Obsidian-Image-Server/main/img/flexbox19.png)\n\n<br>\n\n> 🚩 **Flex 속성의 값**\n\ndefault 값 = flex: 0 1 auto;\n\nflex: <grow(팽창 지수)> <shrink(수축 지수)> <basis(기본크기)>\n\n값은 1개씩 따로 설정도 가능\n\n<br>\n\ngrow = 총합 비율로 공간을 차지\n\nshrink = grow와 같이 사용 X 권장\n\nbasis = grow의 속성이 0일떄 basis 크기를 지정할때만 크기 유지\n\n\n\\* 실제로 1:1:1 의너비를 갖는 flex-basis 사례를 구글링 해보자\n\n------\n\n## 📘 정리\n\n1. **flexbox는 기준축을 중심으로 아이템을 정렬하는 방식이다.**\n2. **기준축(row/column)에 따라,** **justify-content와 align-items의 정렬방식이 결정된다.**\n3. **정렬을 할 수 있는 충분한 가로값, 세로값을 flex-container(부모태그)에 줘야지만 실제로 정렬이 일어남.**\n\n<br>\n\n**flex-direction: row** [가로축 정렬]\n**justify-content**: 가로정렬의 세부적인 정렬 지정\n**align-items**: 세로정렬의 세부적인 정렬 내용 지정\n(center, space-between!, space-around, flex-start, flex-end)\n\n<br>\n\n> 🚩 **flex-direction**\n\n![img](https://raw.githubusercontent.com/spacedustz/Obsidian-Image-Server/main/img/flexbox20.png)\n\n<br>\n\n> 🚩 **justify-content**\n\n![img](https://raw.githubusercontent.com/spacedustz/Obsidian-Image-Server/main/img/flexbox21.png)\n\n<br>\n\n> 🚩 **flex-wrap**\n\n![img](https://raw.githubusercontent.com/spacedustz/Obsidian-Image-Server/main/img/flexbox22.png)\n\n<br>\n\n**flex-direction이 row 일경우**\n\n- justity-content(가로) / align-items(세로)\n\n<br>\n\n**flex-direction이 column 일경우**\n\n- justity-content(세로) / align-items(가로)\n- align-content\n\n<br>\n\n**order(item의 순서 결정)**\n\n- 1 0 1 2 3 4 ~\n\n\n\n**flex-wrap**\n\n- nowrap,wrap,wrap-reverse\n\n<br>\n\n**flex-flow = flex-direction / flex-wrap 을 합쳐놓은 명령**\n\n- ex) flex-flow: row wrap;'),
                       (5,'HTML & CSS','FlexBox & 단위 & 팁','## 📘 Flex Box & 단위 & 다양한 팁\n\n<br>\n\n> 🚩 **단위 정리**\n\n- **px** : 절대값, 다른값에 영향을 받지 않음\n- **em** : 상위요소의 Font 크기를 기준으로 함. 상위 요소의 Font가 12px이면 1em은 12px이다. (반응형)\n- **rem** : em과 비슷하지만 항상 root(html)의 Font를 기준으로 한다.\n- **%** : 상위 요소 크기 기준 %\n\n---\n\n> 🚩 **@media query**\n\n- 다른 프로그래밍 언어의 if문과 비슷하다.\n- @media () <- 괄호 안에 특정 조건을 만족했을때 적용할 css 코드 작성\n\n```tsx\nconst Input = styled.input`\n    margin-top: 20px;\n    width: 561px;\n    height: 44px;\n    border-radius: 24px;\n    border: 1px solid #dfe1e5;\n    padding-left: 60px;\n    padding-right: 60px;\n    \n    @media (max-width: 768px) {\n        width: 70%;\n        padding-left: 20px;\n        padding-right: 20px;\n    }\n`;\nconst SearchIcon = styled.img`\n    position: relative;\n    left: 40px;\n    color: #9aa0a6;\n    \n    @media (max-width: 768px) {\n        margin-left: 10px;\n    }\n`;\n\nconst Microphone = styled.img`\n    position: relative;\n    right: 40px;\n    color: #9aa0a6;\n\n    @media (max-width: 768px) {\n        margin-right: 10px;\n    }\n`;\n```\n---\n\n> 🚩 **margin: 1px 2px 3px 4px 의미**\n\n- 시계방향 기준 12, 3, 6, 9시 방향으로 픽셀 확장\n\n---\n\n>  **CSS 우선순위**\n\n어느게 우선순위가 제일 높을까\n\n![img](https://raw.githubusercontent.com/spacedustz/Obsidian-Image-Server/main/img/css20.png)\n\n<br>\n\n우선순위 규칙에 따라 id가 우선순위가 제일 높다\n\n![img](https://raw.githubusercontent.com/spacedustz/Obsidian-Image-Server/main/img/css21.png)\n\n---'),
                       (6,'HTML & CSS','ARGB 란?','## 📘 ARGB란?\n\n어떤 사진에 1가지 종류의 꽃이 있고, 동일한 종의 꽃이지만 색깔은 2가지(흰색, 보라색)로 나뉘는 사진이 있습니다.\n\n사진은 3036 x 4048이며 대략 1200만 픽셀로 이루어져 있고, 각 픽셀의 색깔은 **ARGB**로 불리는 4가지 Byte로 표현됩니다.\n\n- **A (Alpha)** : 픽셀의 투명도 값을 나타냄\n- **R (Red)** : 빨간색\n- **G (Green)** : 초록색\n- **B (Blue)** : 파란색\n\nRGB의 조합으로 모든 색을 표현할 수 있습니다.\n\n<br>\n\n> 🚩 **예시**\n\n- 만약 일반 RGB의 16진수 색상의 값이 `#8D43CF`라고 가정한다면,\n- rgba()의 4번쨰 파라미터에 Alpha의 값만 넣어주면 내부적으로 16진수 값의 색상 코드로 변환됩니다.\n- ex: `#8D43CFEE`\n\n<br>\n\n```css\n.main {\n    background-color: rgba(255, 0, 1, 2.5);\n}\n```\n\n---\n\n> 🚩 **만약 ARGB값에서 특정 색만 뽑고 싶다면?**\n\n- 32비트에서 각각의 8비트 공간은 A, R, G ,B 순으로 존재합니다.\n\n|A 25~32|R 17~24|G 9~16|B 1~8|\n|---|---|---|---|\n|0000 0000|0000 0000|0000 0000|0000 0000|\n\n\n- 만약 R 부분을 제외한 나머지 비트들을 전부 &(AND) 연산 후, R값은 테이블의 17~24번쨰 비트에 있으니\n- 16칸 >> 쉬프트 연산을 통해 R 값을 뽑아내는 겁니다.\n\n<br>\n\n> 🚩 **만약 ARGB값에서 특정 색만 넣고 싶다면?** \n\n- 위와 반대로 위치를 이동시킨 RGB 비트 값에 |(OR) 연산을 하고 반대 방향으로쉬프트 연산을 하면 됩니다.'),
                       (7,'HTML & CSS','BootStrap 사용법','## 📘 BootStrap\n\n[BootStrap Link](https://getbootstrap.com/docs/5.1/layout/grid/)\n\nBootStrap은 반응형 웹페이지를 만드는데 특화 되어 있습니다.\n\n화면을 격자무늬로 나누고 요소를 배치하는 기술로, 사이즈에 따라 격자 구조를 바꿀 수 있습니다.\n\n<br>\n\n> 🚩 **CDN**\n\n- BootStrap CDN은 JS파일도 포함 합니다.\n- CSS Link : `https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css`\n- JS Link : `https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js`\n\n```html\n<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    <title>Bootstrap demo</title>\n    <link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css\" rel=\"stylesheet\" integrity=\"sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN\" crossorigin=\"anonymous\">\n  </head>\n  <body>\n    <h1>Hello, world!</h1>\n    <script src=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js\" integrity=\"sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL\" crossorigin=\"anonymous\"></script>\n  </body>\n</html>\n```\n\n<br>\n\n> 🚩 **React + TypeScript Module**\n\n- `yarn global add react-bootstrap bootstrap`\n- or\n- `npm i @types/react-bootstrap`\n\n<br>\n\n**main.tsx**\n\n- `import \'bootstrap/dist/css/bootstrap.min.css\';`\n\n<br>\n\n**사용할 컴포넌트**\n\n```tsx\nimport React from \"react\";  \nimport {Button} from \"react-bootstrap\";  \n  \nconst Day8:React.FC = () => {  \n    return (  \n        <div>  \n            <Button variant=\"primary\">Primary Button</Button>  \n        </div>  \n    )  \n}  \n  \nexport default Day8;\n```\n\n<br>\n\n> 🚩 **BootStrap Grid System**\n\n- 1줄의 최대값은 12이고 화면을 알맞은 col-{num}으로 편하게 분할 가능\n- className=\"row\"\n- 하위 요소 className=\"col-3\"\n- 12를 넘으면 다음줄로 넝어감\n- 화면 크기마다 다른 비율 -> className=\"col-lg-3 col-md-6 col-sm-12\"\n\n<br>\n\n> 🚩 **BootStrap Container**\n\n- 동적으로 UI 크기 조절을 해주는 컨테이너'),
                       (8,'JavaScript','Strict Mode & Variable & Type','## 📘 Strict Mode\n\n자바스크립트는 꽤 오랫동안 호환성 이슈 없이 발전해왔습니다. 기존의 기능을 변경하지 않으면서 새로운 기능이 추가되었죠.\n\n<br>\n\n덕분에 기존에 작성한 코드는 절대 망가지지 않는다는 장점이 있었습니다. 하지만 자바스크립트 창시자들이 했던 실수나 불완전한 결정이 언어 안에 영원히 박제된다는 단점도 생겼습니다.\n\n<br>\n\n이런 상황은 ECMAScript5(ES5)가 등장하기 전인 2009년까지 지속되었습니다. 그런데 새롭게 제정된 ES5에서는 새로운 기능이 추가되고 기존 기능 중 일부가 변경되었습니다. 기존 기능을 변경하였기 때문에 하위 호환성 문제가 생길 수 있겠죠? 그래서 변경사항 대부분은 ES5의 기본 모드에선 활성화되지 않도록 설계되었습니다. 대신 `use strict`라는 특별한 지시자를 사용해 엄격 모드(strict mode)를 활성화 했을 때만 이 변경사항이 활성화되게 해놓았습니다.\n\n<br>\n\n### use strict\n\n지시자 `\"use strict\"`, 혹은 `\'use strict\'`는 단순한 문자열처럼 생겼습니다.\n\n하지만 이 지시자가 스크립트 최상단에 오면 스크립트 전체가 “모던한” 방식으로 동작합니다.\n\n이 `use strict`는 함수 본문 맨 앞에 올 수도 있습니다.\n\n```javascript\nfuntion() {\n       \'use strict\';\n}\n```\n\n<br>\n\n한번 `use strict`가 적용되면 돌이킬 방법은 없으니 신중하게 사용해야 합니다.\n\n하지만 개발을 할떄 클래스, 모듈을 당연히 이용할텐데 이럴 경우 use strict는 생략해도 됩니다.\n\n---\n## 📘 변수와 상수\n\nlet, const 키워드를 사용하며,\n\nlet은 가변, const는 불변 변수를 선언할때 사용합니다.\n\nconst는 보통 변수 선언을 대문자로 합니다.\n\n<br>\n\n### 한줄에 여러 변수 선언\n\n```javascript\nlet user = \'Kim\'m age = 25, message = \'Hello\';\n```\n\n\n---\n## 📘 자료형\n\n자바스크립트에서 값은 항상 문자열이나 숫자형 같은 특정한 자료형에 속합니다.\n\n8가지 기본 자료형이 있습니다.\n\n<br>\n\n### 숫자형\n\n- 숫자형 값의 끝에 `n`이 붙으면 BigInt 자료형입니다\n    - 내부 표현 방식 때문에 자바스크립트에선 `(253-1)`(`9007199254740991`) 보다 큰 값 혹은 `-(253-1)` 보다 작은 정수는 \'숫자형’을 사용해 나타낼 수 없습니다.\n    - `BigInt`형은 표준으로 채택된 지 얼마 안 된 자료형으로, 길이에 상관없이 정수를 나타낼 수 있습니다.\n    - `BigInt`형 값은 정수 리터럴 끝에 `n`을 붙이면 만들 수 있습니다.\n- 숫자형에는 일반적인 숫자 외에 `Infinity`, `-Infinity`, `NaN`같은 `특수 숫자 값`이 포함됩니다.\n    - `Infinity`는 어떤 숫자보다 더 큰 특수 값, **무한대**를 나타냅니다.\n    - Infinity 자체를 직접 참조할 수 있습니다.\n    - NaN은 정의되지 않은 수학 연산을 사용하면 발생합니다. (ex: 문자열 + 숫자)\n\n<br>\n\n```javascript\nalert(1/0); // 무한대\nalert(Infinity); // 무한대 직접 참조\nalert(\'A\' + 2); // NaN 발생\n```\n\n<br>\n\n### 문자형\n\n자바스크립트에선 문자열(string)을 따옴표로 묶습니다.\n\n```javascript\nlet str = \"Hello\";\nlet str2 = \'Hello2\';\nlet str3 = `can embed another ${str}`;\n```\n\n<br>\n\n따옴표는 세 종류가 있습니다.\n\n1. 큰따옴표: `\"Hello\"`\n2. 작은따옴표: `\'Hello\'`\n3. 역 따옴표(백틱, backtick): `` `Hello` ``\n\n<br>\n\n큰따옴표와 작은따옴표는 ‘기본적인’ 따옴표로, 자바스크립트에서는 이 둘에 차이를 두지 않습니다.\n\n역 따옴표로 변수나 표현식을 감싼 후 `${…}`안에 넣어주면, 아래와 같이 원하는 변수나 표현식을 문자열 중간에 손쉽게 넣을 수 있습니다.\n\n<br>\n\n```javascript\nlet name = \"Kim\";\n\n// 변수를 문자열 중간에 삽입\nalert(`Hello, ${name}!`);\n\n// 표현식을 문자열 중간에 삽입\nalert(`The Result is ${1+2}`);\n```\n\n<br>\n\n### 불린형\n\n불린형(논리 타입)은 `true`와 `false` 두 가지 값밖에 없는 자료형입니다.\n\n불린형은 긍정(yes)이나 부정(no)을 나타내는 값을 저장할 때 사용합니다. `true`는 긍정, `false`는 부정을 의미합니다.\n\n너무 잘 아니까 넘어가겠습니다.\n\n<br>\n\n### Null 값\n\n`null` 값은 지금까지 소개한 자료형 중 어느 자료형에도 속하지 않는 값입니다.\n\n`null` 값은 오로지 `null` 값만 포함하는 별도의 자료형을 만듭니다.\n\n<br>\n\n자바스크립트의 `null`은 자바스크립트 이외 언어의 `null`과 성격이 다릅니다.\n\n다른 언어에선 `null`을 \'존재하지 않는 객체에 대한 참조’나 \'널 포인터(null pointer)\'를 나타낼 때 사용합니다.\n\n<br>\n\n하지만 자바스크립트에선 `null`을 ‘존재하지 않는(nothing)’ 값, ‘비어 있는(empty)’ 값, ‘알 수 없는(unknown)’ 값을 나타내는 데 사용합니다.\n\n`let age = null;`은 `나이(age)`를 알 수 없거나 그 값이 비어있음을 보여줍니다.\n\n<br>\n\n### Undefined 값\n\n`undefined` 값도 `null` 값처럼 자신만의 자료형을 형성합니다.\n\n`undefined`는 \'값이 할당되지 않은 상태’를 나타낼 때 사용합니다.\n\n변수는 선언했지만, 값을 할당하지 않았다면 해당 변수에 `undefined`가 자동으로 할당됩니다.\n\n<br>\n\n```javascript\nlet age;\n\nalert(age); // Undefined가 출력됩니다.\n```\n\n<br>\n\n개발자가 변수에 `undefined`를 명시적으로 할당하는 것도 가능하긴 합니다.\n\n하지만 권장하지 않는 방법이며, Null 값을 넣는걸 추천합니다.\n\n<br>\n\n### 객체와 심볼\n\n`객체(object)`형은 특수한 자료형입니다.\n\n객체형을 제외한 다른 자료형은 문자열이든 숫자든 한 가지만 표현할 수 있기 때문에 원시(primitive) 자료형이라 부릅니다.\n\n반면 객체는 데이터 컬렉션이나 복잡한 개체(entity)를 표현할 수 있습니다.\n\n<br>\n\n`심볼(symbol)`형은 객체의 고유한 식별자(unique identifier)를 만들 때 사용됩니다.\n\n<br>\n\n### typeof 연산자\n\n`typeof` 연산자는 인수의 자료형을 반환합니다.\n\n자료형에 따라 처리 방식을 다르게 하고 싶거나 변수의 자료형을 빠르게 알아내고자 할 때 유용합니다.\n\n<br>\n\n`typeof` 연산자는 두 가지 형태의 문법을 지원합니다.\n\n1. 연산자: `typeof x`\n2. 함수: `typeof(x)`\n\n괄호가 있든 없든 결과가 동일합니다.\n\n`typeof x`를 호출하면 인수의 자료형을 나타내는 문자열을 반환합니다.\n\n<br>\n\n```javascript\ntypeof undefined // undefined\n\ntypeof 0 // number\n\ntypeof 10n // bigint\n\ntypeof true // boolean\n\ntypeof \"foo\" // string\n\ntypeof Symbol(\"id\") // symbol\n\ntypeof Math // object\n\ntypeof null // object\n\ntypeof alert // funtion\n```\n\n---\n## 📘 요약\n\n자바스크립트에는 여덟 가지 기본 자료형이 있습니다.\n\n- `숫자형` – 정수, 부동 소수점 숫자 등의 숫자를 나타낼 때 사용합니다. 정수의 한계는 ±253 입니다.\n- `bigint` – 길이 제약 없이 정수를 나타낼 수 있습니다.\n- `문자형` – 빈 문자열이나 글자들로 이뤄진 문자열을 나타낼 때 사용합니다. 단일 문자를 나타내는 별도의 자료형은 없습니다.\n- `불린형` – `true`, `false`를 나타낼 때 사용합니다.\n- `null` – `null` 값만을 위한 독립 자료형입니다. `null`은 알 수 없는 값을 나타냅니다.\n- `undefined` – `undefined` 값만을 위한 독립 자료형입니다. `undefined`는 할당되지 않은 값을 나타냅니다.\n- `객체형` – 복잡한 데이터 구조를 표현할 때 사용합니다.\n- `심볼형` – 객체의 고유 식별자를 만들 때 사용합니다.\n\n<br>\n\n`typeof` 연산자는 피연산자의 자료형을 알려줍니다.\n\n- `typeof x` 또는 `typeof(x)` 형태로 사용합니다.\n- 피연산자의 자료형을 문자열 형태로 반환합니다.\n- `null`의 typeof 연산은 `\"object\"`인데, 이는 언어상 오류입니다. null은 객체가 아닙니다.'),
(9,'JavaScript','Alert & Prompt & Confirm','## 📘 Alert\n\n이 함수가 실행되면 사용자가 ‘확인(OK)’ 버튼을 누를 때까지 메시지를 보여주는 창이 계속 떠있게 됩니다.\n\n<br>\n\n```javascript\nalert(\"Hello\");\n```\n\n<br>\n\n메시지가 있는 작은 창은 _모달 창(modal window)_ 이라고 부릅니다.\n\n\'모달’이란 단어엔 페이지의 나머지 부분과 상호 작용이 불가능하다는 의미가 내포되어 있습니다.\n\n따라서 사용자는 모달 창 바깥에 있는 버튼을 누른다든가 하는 행동을 할 수 없습니다. 확인 버튼을 누르기 전까지 말이죠.\n\n---\n## 📘 Prompt\n\n브라우저에서 제공하는 `prompt` 함수는 두 개의 인수를 받습니다.\n\n<br>\n\n```javascript\nresult = prompt(title, [default]);\n```\n\n<br>\n\n함수가 실행되면 텍스트 메시지와 입력 필드(input field), 확인(OK) 및 취소(Cancel) 버튼이 있는 모달 창을 띄워줍니다.\n\n`title` = 사용자에게 보여줄 문자열\n\n`default` = 입력 필드의 초깃값(선택값)\n\n> `default`를 감싸는 대괄호는 이 매개변수가 필수가 아닌 선택값이라는 것을 의미합니다.\n\n<br>\n\n사용자는 프롬프트 대화상자의 입력 필드에 원하는 값을 입력하고 확인을 누를 수 있습니다.\n\n값을 입력하길 원하지 않는 경우는 취소(Cancel) 버튼을 누르거나 Esc를 눌러 대화상자를 빠져나가면 됩니다.\n\n<br>\n\n`prompt` 함수는 사용자가 입력 필드에 기재한 문자열을 반환합니다. 사용자가 입력을 취소한 경우는 `null`이 반환됩니다.\n\n<br>\n\n```javascript\nlet age = prompt(\'나이를 입력해주세요.\', 100);\n\nalert(`당신의 나이는 ${age}살 입니다.`);\n```\n\n<br>\n\n![Prompt](https://raw.githubusercontent.com/spacedustz/Obsidian-Image-Server/main/img/javascript.png)\n\n<br>\n\n![Prompt2](https://raw.githubusercontent.com/spacedustz/Obsidian-Image-Server/main/img/javascript2.png)\n\n\n---\n## 📘 Confirm\n\n`confirm` 함수는 매개변수로 받은 `question(질문)`과 확인 및 취소 버튼이 있는 모달 창을 보여줍니다.\n\n사용자가 확인 버튼을 누르면 `true`, 그 외의 경우는 `false`를 반환합니다.\n\n<br>\n\n```javascript\nresult = confirm(question);\n```\n\n<br>\n\n```javascript\nlet isBoss = confirm(\"당신이 주인인가요?\");\n\nalert(isBoss); // 확인 버튼을 눌렀다면 true가 출력됩니다.\n```\n\n---\n## 📘 요약\n\n브라우저는 사용자와 상호작용할 수 있는 세 가지 함수를 제공합니다.\n\n<br>\n\n#### `alert`\n\n메시지를 보여줍니다.\n\n<br>\n\n#### `prompt`\n\n사용자에게 텍스트를 입력하라는 메시지를 띄워줌과 동시에, 입력 필드를 함께 제공합니다. 확인을 누르면 `prompt` 함수는 사용자가 입력한 문자열을 반환하고, 취소 또는 Esc를 누르면 `null`을 반환합니다.\n\n<br>\n\n#### `confirm`\n\n사용자가 확인 또는 취소 버튼을 누를 때까지 메시지가 창에 보여집니다. 사용자가 확인 버튼을 누르면 `true`를, 취소 버튼이나 Esc를 누르면 `false`를 반환합니다.\n\n<br>\n\n위 함수들은 모두 모달 창을 띄워주는데, 모달 창이 떠 있는 동안은 스크립트의 실행이 일시 중단됩니다. 사용자가 창을 닫기 전까진 나머지 페이지와 상호 작용이 불가능합니다.\n\n<br>\n\n지금까지 살펴본 세 함수엔 두 가지 제약사항이 있습니다.\n\n1. 모달 창의 위치는 브라우저가 결정하는데, 대개 브라우저 중앙에 위치합니다.\n2. 모달 창의 모양은 브라우저마다 다릅니다. 개발자는 창의 모양을 수정할 수 없습니다.\n\n<br>\n\n이런 제약사항은 간결성을 위해 치러야 할 대가입니다. 창을 더 멋지게 꾸미고 복잡한 상호작용을 가능하게 해주는 다른 방법도 있긴 하지만, \'멋을 위한 부가 기능’이 필요하지 않다면 지금까지 소개해드린 기본 메서드만으로 충분합니다.\n\n---\n## 📘 간단한 페이지 만들어보기\n\n사용자에게 이름을 물어보고, 입력받은 이름을 그대로 출력해주는 페이지를 만들어보기\n\n<br>\n\n자바스크립트 코드\n\n```javascript\nlet name = prompt(\"이름을 입력해주세요.\", \"\");\n\nalert(name);\n```\n\n<br>\n\n전체 페이지\n\n```html\n<!DOCTYPE html>\n<html>\n<body>\n  <script>\n               \'use strict\';\n               let name = prompt(\"이름을 입력해주세요.\", \"\");\n            alert(name);\n  </script>\n</body>\n</html>\n```'),
(10,'JavaScript','Type Conversion','## 📘 Type Conversion (형변환)\n\n함수와 연산자에 전달되는 값은 대부분 적절한 자료형으로 자동 변환됩니다. 이런 과정을 \"형 변환(type conversion)\"이라고 합니다.\n\n<br>\n\n`alert`가 전달받은 값의 자료형과 관계없이 이를 문자열로 자동 변환하여 보여주는 것이나,\n수학 관련 연산자가 전달받은 값을 숫자로 변환하는 경우가 형 변환의 대표적인 예시입니다.\n\n<br>\n\n이 외에, 전달받은 값을 의도를 갖고 원하는 타입으로 변환(명시적 변환)해 주는 경우도 형 변환이라고 할 수 있습니다.\n\n**이 글에서 아직 객체의 형변환은 다루지 않고 Primitive Type에 대한 형변환만 다루겠습니다.**\n\n---\n## 📘 문자 변환\n\n\n문자형으로의 형 변환은 문자형의 값이 필요할 때 일어납니다.\n\n`alert`메서드는 매개변수로 문자형을 받기 때문에, `alert(value)`에서 value는 문자형이어야 합니다.\n\n만약, 다른 형의 값을 전달받으면 이 값은 문자형으로 자동 변환됩니다.\n\n`String(value)` 함수를 호출해 전달받은 값을 문자열로 변환 할 수도 있습니다.\n\n<br>\n\n```javascript\nlet value = true;\nalert(typeof value); // boolean\n\nvalue = String(value); // 변수 value엔 문자열 \"true\"가 저장됨\nalert(typeof value); // string\n```\n\n<br>\n\n`false`는 문자열 `\"false\"`로, `null`은 문자열 `\"null\"`로 변환되는 것과 같이, 문자형으로의 변환은 대부분 예측 가능한 방식으로 일어납니다.\n\n---\n## 📘 숫자 변환\n\n숫자형으로의 변환은 수학과 관련된 함수와 표현식에서 자동으로 일어납니다.\n\n숫자형이 아닌 값에 나누기 `/`를 적용한 경우와 같이 말이죠.\n\n<br>\n\n```javascript\nalert(\"6\" / \"2\"); // 결과값 = 3, 문자열이 숫자형으로 자동 변환된 후 연산이 수행됨\n```\n\n<br>\n\n`Number(value)` 함수를 사용하면 주어진 값(`value`)을 숫자형으로 명시해서 변환할 수 있습니다.\n\n<br>\n\n```javascript\nlet str = \"123\";\nalert(typeof str); // string\n\nlet num = Number(str); // 숫자 123으로 명시적 변환\nalert(typeof num); // number\n```\n\n<br>\n\n숫자형 값을 사용해 무언가를 하려고 하는데 그 값을 문자 기반 폼(form)을 통해 입력받는 경우엔, 이런 명시적 형 변환이 필수입니다.\n\n한편, 숫자 이외의 글자가 들어가 있는 문자열을 숫자형으로 변환하려고 하면, 그 결과는 `NaN`이 됩니다. 예시를 살펴봅시다.\n\n<br>\n\n```javascript\nlet age = Number(\"임의의 문자열 123\");\nalert(age); // NaN 반환, 형변환 실패\n```\n\n<br>\n\n아래는 숫자형으로 변환 시 적용되는 규칙입니다.\n\n<br>\n\n|전달받은 값|형변환 후|\n|---|---|\n|undefined|NaN|\n|null|0|\n|true & false | 1, 0|\n|string|문자열의 처음과 끝 공백이 제거됩니다. 공백 제거 후 남아있는 문자열이 없다면 0, 그렇지 않으면 문자열에서 숫자를 읽습니다. 변환에 실패하면 NaN이 됩니다.|\n\n<br>\n\n예시:\n\n```javascript\nalert(Number(\"   123   \")); // 123\nalert(Number(\"123z\")); // NaN\nalert(Number(true)); // 1\nalert(Number(false)); // 0\nalert(Number(null)); // 0\n\nlet a;\nalert(Number(a)); // NaN\n```\n\n---\n## 📘 Boolean 변환\n\n불린형으로의 변환은 아주 간단합니다.\n\n이 형 변환은 논리 연산을 수행할 때 발생합니다.\n\n`Boolean(value)`를 호출하면 명시적으로 불리언으로의 형 변환을 수행할 수 있습니다.\n\n<br>\n\n불린형으로 변환 시 적용되는 규칙은 다음과 같습니다.\n\n- 숫자 `0`, 빈 문자열, `null`, `undefined`, `NaN`과 같이 직관적으로도 “비어있다고” 느껴지는 값들은 `false`가 됩니다.\n- 그 외의 값은 `true`로 변환됩니다.\n\n<br>\n\n예시:\n\n```javascript\nalert(Boolean(1)); // true\nalert(Boolean(0)); // false\n\nalert(Boolean(\"Hello\")); // true\nalert(Boolean(\" \")) // true\nalert(Boolean(\"\")); // false\n```\n\n<br>\n\n**주의: 문자열 \"0\"은 \"true\"입니다.**\n\n- PHP 등의 일부 언어에선 문자열 `\"0\"`을 `false`로 취급합니다. 그러나 자바스크립트에선 비어 있지 않은 문자열은 언제나 `true`입니다.\n\n---\n## 📘 요약\n\n문자, 숫자, 논리형으로의 형 변환은 자주 일어나는 형 변환입니다.\n\n**`문자형으로 변환`** 은 무언가를 출력할 때 주로 일어납니다. `String(value)`을 사용하면 문자형으로 명시적 변환이 가능합니다. 원시 자료형을 문자형으로 변환할 땐, 대부분 그 결과를 예상할 수 있을 정도로 명시적인 방식으로 일어납니다.\n\n<br>\n\n**`숫자형으로 변환`** 은 수학 관련 연산시 주로 일어납니다. `Number(value)`로도 형 변환을 할 수 있습니다.\n\n<br>\n\n숫자형으로의 변환은 다음 규칙을 따릅니다.\n\n|전달받은 값|형 변환 후|\n|---|---|\n|`undefined`|`NaN`|\n|`null`|`0`|\n|`true / false`|`1 / 0`|\n|`string`|전달받은 문자열을 “그대로” 읽되, 처음과 끝의 공백을 무시합니다. 문자열이 비어있다면 `0`이 되고, 오류 발생 시 `NaN`이 됩니다.|\n\n**`불린형으로 변환`** 은 논리 연산 시 발생합니다. `Boolean(value)`으로도 변환할 수 있습니다.\n\n<br>\n\n불린형으로의 형 변환은 다음 규칙을 따릅니다.\n\n|전달받은 값|형 변환 후|\n|---|---|\n|`0`, `null`, `undefined`, `NaN`, `\"\"`|`false`|\n|그 외의 값|`true`|\n\n<br>\n\n형 변환 시 적용되는 규칙 대부분은 이해하고 기억하기 쉬운 편에 속합니다. 다만 아래는 예외적인 경우이기 때문에 실수를 방지하기 위해 따로 기억해 두도록 합시다.\n\n- 숫자형으로 변환 시 `undefined`는 `0`이 아니라 `NaN`이 됩니다.\n- 문자열 `\"0\"`과 `\" \"`같은 공백은 불린형으로 변환 시 true가 됩니다.'),
(11,'JavaScript','Operator & Condition','## 📘 Operators\n\n자바스크립트에서의 기본 연산자는 다음과 같습니다.\n\n-   덧셈 연산자 `+`,\n-   뺄셈 연산자 `-`,\n-   곱셈 연산자 `*`,\n-   나눗셈 연산자 `/`,\n-   나머지 연산자 `%`,\n-   거듭제곱 연산자 `**`\n\n<br>\n\n나머지 연산자(remainder operator)는 `%` 기호로 나타내지만, 비율을 나타내는 퍼센트와 관련이 없습니다.\n\n나머지 연산자를 사용한 표현식 `a % b`는 `a`를 `b`로 나눈 후 그 나머지([remainder](https://en.wikipedia.org/wiki/Remainder))를 정수로 반환해줍니다.\n\n<br>\n\n거듭제곱 연산자(exponentiation operator)를 사용한 `a ** b`를 평가하면 `a`를 `b`번 곱한 값이 반환됩니다.\n\n---\n\n## 📘 if & ? 을 이용한 조건 처리\n\n다른 언어와 마찬가지로 if 줄이 1줄일때, `{}`를 생략할 수 있습니다.\n\nif문은 다른 언어와 비슷하므로 대충 작성합니다.\n\n<br>\n\n```javascript\nif (year == 2023) alert(\'정답입니다!\');\n```\n\n<br>\n\n### Boolean 변환\n\n`if (…)` 문은 괄호 안의 표현식을 평가하고 그 결과를 불린값으로 변환합니다.\n\n-   숫자 `0`, 빈 문자열`\"\"`, `null`, `undefined`, `NaN`은 불린형으로 변환 시 모두 `false`가 됩니다. 이런 값들은 ‘falsy(거짓 같은)’ 값이라고 부릅니다.\n-   이 외의 값은 불린형으로 변환시 `true`가 되므로 ‘truthy(참 같은)’ 값이라고 부릅니다.\n\n이 규칙에 따르면 아래 예시의 코드 블록은 절대 실행되지 않습니다.\n\n<br>\n\n```javascript\nif (0) {} // 0은 false, 실행 불가능\n\nif (1) {} // 1은 true, 항상 실행 가능\n\nlet cond = (year == 2023); // 동등성 비교를 통해 true/false 결정\nif (cond) {} // year이 2023이면 실행\n```\n\n---\n## 📘 ? 조건부 연산자\n\n`?` 조건부 연산자도 자바와 동일합니다.\n\n기본적인 설명은 생략하고, 주의할점만 상기하자면 이 조건부 연산자를 if문 대용으로 쓰는 경우가 종종있습니다.\n\n결론부터 말하면 if문 대용으로 `?`를 쓰는것은 가독성에 좋지 않기 때문에 왠만하면 if..else 문을 사용하길 권장합니다.\n\n'),
(12,'JavaScript','Nullish 병합 연산자 \'??\'','## 📘 Nullish 병합 연산자 \'??\'\n\nnullish 병합 연산자(nullish coalescing operator) `??`를 사용하면 짧은 문법으로 여러 피연산자 중 그 값이 ‘확정되어있는’ 변수를 찾을 수 있습니다.\n\nKotlin의 Elvis 연산자와 `!!` 키워드와 비슷한 느낌이지만 다른것 같습니다.\n\n<br>\n\n`a ?? b`의 평가 결과는 다음과 같습니다.\n\n-   `a`가 `null`도 아니고 `undefined`도 아니면 `a`\n-   그 외의 경우는 `b`\n\nnullish 병합 연산자 `??`없이 `x = a ?? b`와 동일한 동작을 하는 코드를 풀어보면 다음과 같습니다.\n\n```javascript\nx = (a !== null && a !== undefined) ? a : b;\n```\n\n<br>\n\n또 다른 예시를 살펴봅시다. `firstName`, `lastName`, `nickName`이란 변수에 사용자 이름이나 별명을 저장하는데, 사용자가 아무런 정보도 입력하지 않는 케이스도 허용한다고 해보겠습니다.\n\n화면엔 세 변수 중 실제 값이 있는 변수의 값을 출력하는데, 세 변수 모두 값이 없다면 \'익명의 사용자’가 출력되도록 해보죠.\n\n이럴 때 nullish 병합 연산자 `??`를 사용하면 값이 정해진 변수를 간편하게 찾아낼 수 있습니다.\n\n```javascript\nlet firstName = null;\nlet lastName = null;\nlet nickName = \"바이올렛\";\n\n// Null이나 Undefined가 아닌 첫번째 피연산자\nalert(firstName ?? lastName ?? nickName ?? \"익명 사용자\"); // 출력값 : 바이올렛\n```\n\n---\n## 📘 \'??\'와 \'||\'의 차이\n\nnullish 병합 연산자는 OR 연산자 `||`와 상당히 유사해 보입니다.\n\n실제로 위 예시에서 `??`를 `||`로 바꿔도 그 결과는 동일하기까지 하죠.\n\n<br>\n\n그런데 두 연산자 사이에는 중요한 차이점이 있습니다.\n\n-   `||`는 첫 번째 _truthy_ 값을 반환합니다.\n-   `??`는 첫 번째 _정의된(defined)_ 값을 반환합니다.\n\n`null`과 `undefined`, 숫자 `0`을 구분 지어 다뤄야 할 때 이 차이점은 매우 중요한 역할을 합니다.\n\n```javascript\n// height에 값이 정의되어 있지 않은 경우 height엔 100이 할당됩니다.\nheight = height ?? 100;\n```\n\n<br>\n\n이제 \'??\'와 \'||\'를 비교해봅시다.\n\n```javascript\nlet height = 0;\n\nalert(height || 100); // 100\nalert(height ?? 100); // 0\n```\n\n<br>\n\n`height || 100`은 `height`에 `0`을 할당했지만 `0`을 falsy 한 값으로 취급했기 때문에 `null`이나 `undefined`를 할당한 것과 동일하게 처리합니다. 따라서 `height || 100`의 평가 결과는 `100`입니다.\n\n<br>\n\n반면 `height ?? 100`의 평가 결과는 `height`가 정확하게 `null`이나 `undefined`일 경우에만 `100`이 됩니다. 예시에선 `height`에 `0`이라는 값을 할당했기 때문에 얼럿창엔 `0`이 출력됩니다.\n\n<br>\n\n이런 특징 때문에 높이처럼 `0`이 할당될 수 있는 변수를 사용해 기능을 개발할 땐 `||`보다 `??`가 적합합니다.\n\n---\n## 📘 연산자 우선순위\n\n[`??`의 연산자 우선순위](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table)는 `5`로 꽤 낮습니다.\n\n따라서 `??`는 `=`와 `?` 보다는 먼저, 대부분의 연산자보다는 나중에 평가됩니다.\n\n그렇기 때문에 복잡한 표현식 안에서 `??`를 사용해 값을 하나 선택할 땐 괄호를 추가하는 게 좋습니다.\n\n```javascript\nlet height = null;\nlet width = null;\n\n// 괄호 추가\nlet area = (height ?? 100) * (width ?? 50);\n\nalert(area); // 5000\n```\n\n<br>\n\n만약 괄호를 붙이지 않으면 `*`가 `??`보다 우선순위가 높기 때문에 `*`가 먼저 실행됩니다.\n\n---\n## 📘 요약\n\n-   nullish 병합 연산자 `??`를 사용하면 피연산자 중 ‘값이 할당된’ 변수를 빠르게 찾을 수 있습니다.\n- `??`는 변수에 기본값을 할당하는 용도로 사용할 수 있습니다.\n\n```javascript\n// height가 null 이나 undefined인 경우, 100 할당\nheight = height ?? 100;\n```\n\n-   `??`의 연산자 우선순위는 대다수의 연산자보다 낮고 `?`와 `=` 보다는 높습니다.\n-   괄호 없이 `??`를 `||`나 `&&`와 함께 사용하는 것은 금지되어있습니다.'),
(13,'JavaScript','Function','## 📘 Function\n\n함수의 정의는 다른 언어들과 동일하기 때문에 기본적인 함수 설명은 생략\n\n<br>\n\n### 함수 파라미터 기본값 설정\n\nKotlin의 Default Parameter와 유사한 구조입니다.\n\n파라미터가 2개 있는 함수에 1개의 파라미터만 전달하게 되면,\n\n값을 할당받지 못한 파라미터는 Undefined 할당됩니다.\n\n<br>\n\n하지만 Undefined를 할당시키기 보다 함수를 선언할 때 기본값을 설정해주는게 더 좋습니다.\n\n```javascript\nfunction showMessage(from, text = \"No Text Given\") {\n      alert(from + \": \" + text);\n}\n\nshowMessage(\"Kim\"); // 결과값 : Kim: No Text Given\n```\n\n<br>\n\n파라미터에 값을 전달해도 그 값이 Undefined와 `엄격히(Strict)` 일치한다면 기본값이 할당됩니다.\n\n```javascript\nshowMessage(\"Kim\", undefined); // Kim: No Text Given\n```\n\n<br>\n파라미터 기본값에 함수를 넣을수도 있습니다.\n\n아래 코드에서 text 파라미터에 값이 들어오지 않았을 경우 anotherFun의 반환값이 text의 값이 되도록 설정했습니다.\n\n```javascript\nfunction showMessage(from, text = anotherFun()) {\n}\n```\n\n<br>\n\n### 파라미터 기본값을 설정하는 또 다른 방법\n\n개발을 하다보면 가끔 함수 선언 시가 아닌, 함수 선언 후 함수 내부에서 기본값을 설정하는 것이 적절한 경우가 있습니다.\n\n이런 경우 함수를 호출할 때 파라미터를 Undefined와 비교하여 파라미터가 전달되었는지를 확인하면 됩니다.\n\n- if 문을 사용한 방법\n- || 연산자를 이용한 방법\n- Nullish 병합 연산자를 이용한 방법\n\n```javascript\n/* if 문을 사용한 방법 */\nfuntion showMessage(text) {\n      if (text === undefined) {\n             text = \'빈 문자열\';\n }\n\n   alert(text);\n}\n\nshowMessage(); // 출력값 = 빈 문자열\n\n\n\n/* || 연산자를 이용한 방법 */\nfuntion showMessage(text) {\n     text = text || \'빈 문자열\';\n}\n\nshowMessage(); // 출력값 = 빈 문자열\n\n\n\n/* Nullish 병합 연산자를 이용한 방법 */\nfuntion showCount(count) {\n   alert(count ?? \"Unknown\");\n}\n\nshowCount(0); // 0\nshowCount(null); // Unknown\nshowCount() // Unknown\n```\n\n---\n## 📘 Expression\n\n자바스크립트는 함수를 특별한 종류의 값으로 취급합니다. 다른 언어에서처럼 \"특별한 동작을 하는 구조\"로 취급되지 않습니다.\n\n즉 함수를 Expression(식)으로도 사용할 수 있다는 말이 됩니다.\n\n아래 코드는 변수를 선언하는 것처럼 함수가 변수에 할당된 코드입니다.\n\n```javascript\nlet sayHi = funtion() {\n        alert(\"Hello\");\n};\n```\n\n<br>\n\n#### 위 함수 표현식 끝에 \';\'이 붙는 이유\n-   `if { ... }`, `for { }`, `function f { }` 같이 중괄호로 만든 코드 블록 끝엔 `;`이 없어도 됩니다.\n-   함수 표현식은 `let sayHi = ...;`과 같은 구문 안에서 값의 역할을 합니다. 코드 블록이 아니고 값처럼 취급되어 변수에 할당되죠. 모든 구문의 끝엔 세미 콜론 `;`을 붙이는 게 좋습니다. 함수 표현식에 쓰인 세미 콜론은 함수 표현식 때문에 붙여진 게 아니라, 구문의 끝이기 때문에 붙여졌습니다.\n\n<br>\n\n그리고 자바스크립트에서 함수는 값으로 표현될 수 있기 떄문에 함수의 코드 자체를 출력할 수도 있습니다.\n\n```javascript\nfunction sayHi() {\n     alert(\"Hello\");\n}\n\nalert(sayHi); // 함수 코드 출력\n```\n\n<br>\n\n마지막 줄에서 `sayHi`옆에 괄호가 없기 때문에 함수는 실행되지 않습니다. 어떤 언어에선 괄호 없이 함수 이름만 언급해도 함수가 실행됩니다. 하지만 자바스크립트는 괄호가 있어야만 함수가 호출됩니다.\n\n자바스크립트에서 함수는 값입니다. 따라서 함수를 값처럼 취급할 수 있습니다. 위 코드에선 함수 소스 코드가 문자형으로 바뀌어 출력되었습니다.\n\n함수는 `sayHi()`처럼 호출할 수 있다는 점 때문에 일반적인 값과는 조금 다릅니다. 특별한 종류의 값이죠.\n\n<br>\n\n하지만 그 본질은 값이기 때문에 값에 할 수 있는 일을 함수에도 할 수 있습니다.\n\n변수를 복사해 다른 변수에 할당하는 것처럼 함수를 복사해 다른 변수에 할당할 수도 있습니다.\n\n```javascript\n// 함수 생성\nfuntion sayHi() {\n  alert(\"Hello\");\n}\n\nlet func = sayHi; // 함수 복사\n\nfunc(); // 복사한 함수 실행, 출력값 : Hello\nsayHi(); // 원래 함수도 정상 실행, 출력값 : Hello\n```\n\n<br>\n\n1.  `(1)`에서 함수 선언 방식을 이용해 함수를 생성합니다. 생성한 함수는 `sayHi`라는 변수에 저장됩니다.\n2.  `(2)` 에선 `sayHi`를 새로운 변수 `func`에 복사합니다. 이때 `sayHi` 다음에 괄호가 없다는 점에 유의하시기 바랍니다. 괄호가 있었다면 `func = sayHi()` 가 되어 `sayHi` _함수_ 그 자체가 아니라, _함수 호출 결과(함수의 반환 값)_ 가 `func`에 저장되었을 겁니다.\n3.  이젠 `sayHi()` 와 `func()`로 함수를 호출할 수 있게 되었습니다.\n\n---\n## 📘 CallBack Function\n\n함수를 값처럼 전달하는 예시, 함수 표현식에 관한 예시를 좀 더 살펴보겠습니다.\n\n<br>\n\n매개변수가 3개 있는 함수, `ask(question, yes, no)`를 작성해보겠습니다. 각 매개변수에 대한 설명은 아래와 같습니다.\n\n- `question` = 질문\n- `yes` = \"Yes\"라고 답한 경우 실행되는 함수\n- `no` = \"No\"라고 답한 경우 실행되는 함수\n\n<br>\n\n함수는 반드시 `question(질문)`을 해야 하고, 사용자의 답변에 따라 `yes()` 나 `no()`를 호출합니다.\n\n```javascript\nfunction ask(question, yes, no) {\n if (confirm(question)) yes() \nelse no();\n}\n\nfunction showOk() { alert(\"동의합니다.\"); }\nfunction showCnacle() { alert(\"취소하셨습니다.\"); }\n\nask(\"동의하십니까?\", showOk, showCancle);\n```\n\n<br>\n\n**함수 `ask`의 인수, `showOk`와 `showCancel`은 _콜백 함수_ 또는 _콜백_이라고 불립니다.**\n\n함수를 함수의 인수로 전달하고, 필요하다면 인수로 전달한 그 함수를 \"나중에 호출(called back)\"하는 것이 콜백 함수의 개념입니다. 위 예시에선 사용자가 \"yes\"라고 대답한 경우 `showOk`가 콜백이 되고, \"no\"라고 대답한 경우 `showCancel`가 콜백이 됩니다.\n\n<br>\n\n아래와 같이 익명 함수와 함수 표현식을 사용하면 코드 길이가 짧아집니다.\n\n익명 함수에 대한 설명은 생략하겠습니다.\n\n```javascript\nfunction ask(question, yes, no) {\n    if (confirm(question)) yes()\n  else no();\n}\n\nask(\n \"동의하십니까?\",\n    function() { alert(\"동의합니다.\"); },\n      function() { alert(\"취소하셨습니다.\"); }\n);\n```'),
(14,'JavaScript','Object','## 📘 Object\n\n자바스크립트에서 객체는 중괄호 `{…}`를 이용해 만들 수 있습니다. \n\n중괄호 안에는 ‘키(key): 값(value)’ 쌍으로 구성된 _프로퍼티(property)_ 를 여러 개 넣을 수 있는데,\n\n`키`엔 문자형, `값`엔 모든 자료형이 허용됩니다. 프로퍼티 키는 ‘프로퍼티 이름’ 이라고도 부릅니다.\n\n<br>\n\n빈 객체를 만드는 2가지 방법이 있습니다.\n\n- 객체 생성자 문법\n- 객체 리터럴 문법\n\n```javascript\nlet user = new Object(); // 객체 생성자\nlet user = {}; // 객체 리터럴\n```\n\n<br>\n\n보통 객체 선언 시 리터럴 {...} 을 사용합니다.\n\n---\n## 📘 Literal & Property\n\n자바스크립트의 객체 내부 {...} 안의 프로퍼티들은 Json 처럼 `키 : 값` 쌍으로 구성된 프로퍼티가 들어갑니다.\n\n```javascript\nlet user = {\n  name: \"Kim\",\n        age: 20\n};\n\n// 객체 프로퍼티 값 출력\nalert(user.name);\nalert(user.age);\n```\n\n<br>\n\n### Property 삭제\n\n`delete` 연산자를 사용해 객체의 프로퍼티를 삭제할 수 있습니다.\n\n```javascript\ndelete user.age;\n```\n\n<br>\n\n### 여러 단어를 조합한 Property 선언\n\n여러 단어를 조합해 프로퍼티 이름을 만든 경우 프로퍼티 이름을 `\"\"`로 묶어주어야 합니다.\n\n그리고, 여러 단어를 조합한 프로퍼티를 제어할때 **대괄호 표기법**을 사용해야 합니다.\n\n```javascript\nlet user = {\n   name: \"Kim\",\nage: 20,\n      \"likes birds\": true\n}\n\n/* 여러 단어를 조합한 프로퍼티 제어 */\nuser.[\"likes birds\"] = true; // set property\nalert(user[\"likes birds\"]);  // get property\ndelete user[\"likes birds\"];  // delete property\n```\n\n<br>\n**변수를 Key로 사용할 수도 있습니다.**\n\n아래 코드의 변수 key는 런타임 시 평가되기 때문에 사용자 입력값 변경 등에 따라 값이 변경될 수 있습니다.\n\n```javascript\nlet key = \"likes birds\";\n\n// user[\"likes birds\"] = true 와 같다.\nuser[key] = true;\n```\n\n<br>\n\n어떤 경우든, 평가가 끝난 이후의 결과가 프로퍼티 키로 사용됩니다.\n\n이를 응용하면 코드를 유연하게 작성할 수 있습니다. (점 표기법은 이런 방식 불가능)\n\n```javascript\nlet user = {\n name: \"Kim\",\n        age: 20\n};\n\nlet key = prompt(\"사용자의 어떤 정보를 알고 싶으신가요?\", \"name\");\n\n// 변수로 접근\nalert(user[key]); \n```\n\n<br>\n\n**계산된 프로퍼티**\n\n객체를 만들 때 객체 리터럴 안의 프로퍼티 키가 대괄호로 둘러쌓여 있는 경우,\n\n이를 계산된 프로퍼티(Computed Property)라고 부릅니다.\n\n아래 코드는 변수 fruit에서 프로퍼티 이름을 동적으로 받아옵니다.\n\n사용자가 프롬프트 대화상자에 `apple`을 입력했다면 `bag`엔 `{apple: 5}`가 할당되었을 겁니다.\n\n```javascript\nlet fruit = prompt(\"어떤 과일을 구매하시겠습니까?\", \"apple\");\n\nlet bag = {\n   [fruit]: 5\n}\n\n// frult 변수에 apple이 할당되었다면 숫자 5 출력\nalert(bag.apple);\n```\n\n<br>\n\n**단축 프로퍼티**\n\n실무에선 프로퍼티 값을 기존 변수에서 받아와 사용하는 경우가 종종 있습니다.\n\n```javascript\nfunction makeUser(name, age) {\n        return {\n              name, age\n     };\n}\n\nlet user = makeUser(\"Kim\", 20);\nalert(user.name);\n```\n\n<br>\n\n한 객체에서 일반 프로퍼티와 단축 프로퍼티를 함께 사용하는 것도 가능합니다.\n\n```javascript\nlet user = {\n      name, // name = name 과 같음\n  age: 20\n};\n```\n\n---\n## 📘 Const Object 수정\n\n`const`로 선언된 객체는 수정될 수 있습니다. 기본적으로 `const`는 불변 변수를 선언할 때 사용하지만,\n\n객체 그 자체의 값은 고정하지만 객체의 내용은 고정하지 않습니다.\n\n```javascript\nconst user = {\n   name: \"Kim\"\n};\n\nuser.name = \"Lee\";\n\nalert(user.name) // 정상 출력\n```\n\n---\n## 📘 \'in\' 연산자를 이용한 Property 존재 여부 확인\n\n다른 언어와 달리 자바스크립트는 존재하지 않는 프로퍼티에 접근하려고 하면 에러가 발생하는게 아닌 `Undefined`를 반환합니다.\n\n이런 특징을 응용하면 프토퍼티 존재 여부를 쉽게 확인할 수 있습니다.\n\n```javascript\nlet user = {};\n\n// true는 \'프로퍼티가 존재하지 않음\'을 의미합니다.\nalert(user.noSuchProperty === undefined);\n```\n\n<br>\n\n문법은 다음과 같습니다.\n\n```javascript\n\"key\" in object\n```\n\n<br>\n\n예시:\n\n```javascript\nlet user = { name: \"Kim\", age: 20 };\n\nalert(\"age\" in user); // true\nalert(\"blabla\" in user); // false\n```\n\n<br>\n\n**그럼 ``===`를 활용한 undefined 비교만해도 충번한데 왜 `in` 연산자를 사용할까요?**\n\n대부분의 경우, 일치 연산자를 사용해서 프로퍼티 존재 여부를 알아내는 방법(`\"=== undefined\"`)은 꽤 잘 동작합니다. \n\n그런데 가끔은 이 방법이 실패할 때도 있습니다. 이럴 때 `in`을 사용하면 프로퍼티 존재 여부를 제대로 판별할 수 있습니다.\n\n<br>\n\n프로퍼티는 존재하는데, 값에 `undefined`를 할당한 예시를 살펴봅시다.\n\n```javascript\nlet obj = { test: undefined };\n\nalert(obj.test); // undefined\nalert(\"test\" in obj); // true\n```\n\n<br>\n\n위 코드에서 `in`을 사용해 프로퍼티 존재유무를 확인하고 있고, 만약 obj 객체에 test 프로퍼티가 없으면 false가 반환되었을 겁니다.\n\n그런데 undefined라는 값이 들어가도 결국 프로퍼티가 존재하니까 true가 반환되는걸 볼 수 있습니다.\n\n`undefined`가 출력되는 경우 중 하나는, 변수는 정의되었으나 값이 할당되지 않은 경우에 출력됩니다.\n\n이 예시의 경우는 값 자체가 `undefined`이기 떄문에 `obj.test` 출력 시 `undefined`가 출력됩니다.\n\n---\n## 📘 For..In\n\nKotlin의 반복문과 동일하므로 설명은 생략하고 사용법만 적습니다.\n\n```javascript\nlet user = {\n   name: \"Kim\",\n        age: 20,\n      isAdmin: true\n};\n\nfor (let key in user) {\n  alert(key); // 출력값 : name, age, isAdmin\n   alert(user[key]); // 출력값: Kim, 20, true\n}\n```\n\n---\n## 📘 객체 정렬 방식\n\n객체와 객체 프로퍼티를 다루다 보면 \"프로퍼티엔 순서가 있을까?\"라는 의문이 생기기 마련입니다. 반복문은 프로퍼티를 추가한 순서대로 실행될지, 그리고 이 순서는 항상 동일할지 궁금해지죠.\n\n<br>\n\n답은 간단합니다. 객체는 \'특별한 방식으로 정렬’됩니다. 정수 프로퍼티(integer property)는 자동으로 정렬되고, 그 외의 프로퍼티는 객체에 추가한 순서 그대로 정렬됩니다. 자세한 내용은 예제를 통해 살펴봅시다.\n\n<br>\n\n아래 객체엔 국제전화 나라 번호가 담겨있습니다.\n\n```javascript\nlet codes = {\n    \"49\": \"독일\",\n     \"41\": \"스위스\",\n   \"44\": \"영국\",\n     \"1\": \"미국\"\n};\n\nfor (let code in codes) {\n      alert(code); // 출력 순서 : 1, 41, 44, 49\n}\n```\n\n<br>\n\n현재 개발 중인 애플리케이션의 주 사용자가 독일인이라고 가정해 봅시다. 나라 번호를 선택하는 화면에서 `49`가 맨 앞에 오도록 하는 게 좋을 겁니다.\n\n<br>\n\n그런데 코드를 실행해 보면 예상과는 전혀 다른 결과가 출력됩니다.\n\n- 미국(1)이 첫 번째로 출력됩니다.\n- 그 뒤로 스위스(41), 영국(44), 독일(49)이 차례대로 출력됩니다.\n\n<br>\n\n이유는 나라 번호(키)가 정수이어서 `1, 41, 44, 49` 순으로 프로퍼티가 자동 정렬되었기 때문입니다.\n\n<br>\n\n> **정수 프로퍼티란?**\n\n변형 없이 정수에서 왔다 갔다 할 수 있는 문자열을 의미합니다.\n\n문자열 \"49\"는 정수로 변환하거나 변환한 정수를 다시 문자열로 바꿔도 변형이 없기 때문에 정수 프로퍼티입니다. \n\n하지만 \'+49’와 \'1.2’는 정수 프로퍼티가 아닙니다.\n\n아래 예시에서 Math.trunc는 소수점 아래는 버리고 숫자의 정부수만 반환하며,\n\n1,2번쨰는 정수 프로퍼티지만 3번째는 정수 프로퍼티가 아닙니다.\n\n```javascript\nalert(String(Math.trunc(Number(\"49\"))) ); // \'49\' 출력\nalert(String(Math.trunc(Number(\"+49\"))) ); // \'49\' 출력\nalert(String(Math.trunc(Number(\"1.2\"))) ); // \'1\' 출력\n```\n\n<br>\n\n위 예시에서 49를 가장 위에 출력되도록 하려면 나라 번호가 정수로 취급되지 않도록,\n\n각 나라 번호 앞에 `\"+49\"` 처럼 `+`를 붙여주고 출력을 할때에도 alert 함수 내부 인자에 `+`를 붙여주면 됩니다.'),
(15,'JavaScript','참조에 의한 객체 복사','## 📘 참조에 의한 객체 복사\n\n객체와 원시 타입의 근본적인 차이 중 하나는 객체는 ‘참조에 의해(by reference)’ 저장되고 복사된다는 것입니다.\n\n원시값(문자열, 숫자, 불린 값)은 ‘값 그대로’ 저장·할당되고 복사되는 반면에 말이죠.\n\n<br>\n\n**변수엔 객체가 그대로 저장되는 것이 아니라, 객체가 저장되어있는 \'메모리 주소’인 객체에 대한 \'참조 값’이 저장됩니다.**\n\n```javascript\nlet user { name: \"Kim\" };\n\nlet admin = user; // 객체의 참조값을 복사함\n```\n\n---\n## 📘 참조에 의한 비교\n\n객체 비교 시 동등 연산자 `==`와 일치 연산자 `===`는 동일하게 동작합니다.\n\n**비교 시 피연산자인 두 객체가 동일한 객체인 경우에 참을 반환하죠.**\n\n두 변수가 같은 객체를 참조하는 예시를 살펴봅시다. 일치·동등 비교 모두에서 참이 반환됩니다.\n\n```javascript\nlet a = {};\nlet b = a; // 참조에 의한 복사\n\nalert(a == b); // true, 두 변수는 같은 객체를 참조함\nalert(a === b); // true\n```\n\n<br>\n다른 예시를 살펴봅시다. 두 객체 모두 비어있다는 점에서 같아 보이지만, 독립된 객체이기 때문에 일치·동등 비교하면 거짓이 반환됩니다.\n\n```javascript\nlet a = {};\nlet b = {}; // 독립된 두 객체\n\nalert(a == b); // false\n```\n\n`obj1 > obj2` 같은 대소 비교나 `obj == 5` 같은 원시값과의 비교에선 객체가 원시형으로 변환됩니다. \n\n객체가 어떻게 원시형으로 변하는지에 대해선 곧 학습할 예정인데, 이러한 비교(객체끼리의 대소 비교나 원시값과 객체를 비교하는 것)가 필요한 경우는 매우 드물긴 합니다. 대개 코딩 실수 때문에 이런 비교가 발생합니다.\n\n---\n## 📘 객체 복사, 병합과 Object.assign\n\n객체가 할당된 변수를 복사하면 동일한 객체에 대한 참조 값이 하나 더 만들어진다는 걸 배웠습니다.\n\n그런데 객체를 복제하고 싶다면 어떻게 해야 할까요? 기존에 있던 객체와 똑같으면서 독립적인 객체를 만들고 싶다면 말이죠.\n\n<br>\n\n방법은 있는데 자바스크립트는 객체 복제 내장 메서드를 지원하지 않기 때문에 조금 어렵습니다. 사실 객체를 복제해야 할 일은 거의 없습니다. 참조에 의한 복사로 해결 가능한 일이 대다수이죠.\n\n정말 복제가 필요한 상황이라면 새로운 객체를 만든 다음 기존 객체의 프로퍼티들을 순회해 원시 수준까지 프로퍼티를 복사하면 됩니다.\n\n아래와 같이 말이죠.\n\n```javascript\nlet user = {\n        name: \"Kim\",\n        age: 30\n}\n\nlet clone = {}; // 새로운 빈 객체\n\n// user 객체의 프로퍼티들을 순회하며 clone 객체의 프로퍼티로 복제\nfor (let key in user) {\nclone[key] = user[key];\n}\n```\n\n<br>\n\n다음은 Object.assign을 이용한 방법입니다.\n\n```javascript\nObject.assign(dest, [src1, src2, src3...])\n```\n\n-   첫 번째 인수 `dest`는 목표로 하는 객체입니다.\n-   이어지는 인수 `src1, ..., srcN`는 복사하고자 하는 객체입니다. `...`은 필요에 따라 얼마든지 많은 객체를 인수로 사용할 수 있다는 것을 나타냅니다.\n-   객체 `src1, ..., srcN`의 프로퍼티를 `dest`에 복사합니다. `dest`를 제외한 인수(객체)의 프로퍼티 전부가 첫 번째 인수(객체)로 복사됩니다.\n-   마지막으로 `dest`를 반환합니다.\n\n<br>\n`assign` 메서드를 사용해 여러 객체를 하나로 병합하는 예시를 살펴봅시다.\n\n```javascript\nlet user = { name: \"Kim\" };\n\nlet permissions1 = { canView: true };\nlet permissions2 = { canEdit: true };\n\n// permissions 1,2의 프로퍼티를 user 객체로 복사합니다.\nObject.assign(user, permissions1, permissions2);\n\n// User의 프로퍼티 : { name: \"John\", canView: true, canEdit: true }\n```\n\n- 목표 객체(`user`)에 동일한 이름을 가진 프로퍼티가 있는 경우엔 기존 값이 assign 함수의 프로포티 값으로 덮어씌워 집니다.\n\n<br>\n\n`Object.assign`을 사용하면 반복문 없이도 간단하게 객체를 복사할 수 있습니다.\n\n```javascript\nlet user = {\n       name: \"Kim\",\n        age: 30\n}\n\nlet clone = Object.assign({}, user);\n```\n\n---\n## 📘 중첩 객체 복사\n\n지금까진 `user`의 모든 프로퍼티가 원시값인 경우만 가정했습니다. \n\n그런데 프로퍼티는 다른 객체에 대한 참조 값일 수도 있습니다. 즉, 객체의 프로퍼티에 객체가 있는 경우이죠.\n\n이 경우는 어떻게 해야 할까요?\n\n```javascript\nlet user = {\n   name: \"Kim\",\n        sizes: {\n              height: 182,\n          width: 50\n     }\n};\n\nlet clone = Object.assign({}, user);\n\nalert(user.sizes === clone.sizes); // true, 같은 객체\n\n// user와 clone은 sizes를 공유합니다.\nuser.sizes.width++; // 한 객체의 프로퍼티 변경\nalert(clone.sizes.width); // 값: 51, 다른 객체에서 변경사항 확인 가능\n```\n\n<br>\n\n이 문제를 해결하려면 `user[key]`의 각 값을 검사하면서, 그 값이 객체인 경우 객체의 구조도 복사해주는 반복문을 사용해야 합니다. 이런 방식을 \'깊은 복사(deep cloning)\'라고 합니다.\n\n깊은 복사 시 사용되는 표준 알고리즘인 [Structured cloning algorithm](https://html.spec.whatwg.org/multipage/structured-data.html#safe-passing-of-structured-data)을 사용하면 위 사례를 비롯한 다양한 상황에서 객체를 복제할 수 있습니다.\n\n자바스크립트 라이브러리 [lodash](https://lodash.com/)의 메서드인 [_.cloneDeep(obj)](https://lodash.com/docs#cloneDeep)을 사용하면 이 알고리즘을 직접 구현하지 않고도 깊은 복사를 처리할 수 있으므로 참고하시기 바랍니다.\n\n---\n## 📘 요약\n\n객체는 참조에 의해 할당되고 복사됩니다. \n\n변수엔 ‘객체’ 자체가 아닌 메모리상의 주소인 \'참조’가 저장됩니다. \n\n따라서 객체가 할당된 변수를 복사하거나 함수의 인자로 넘길 땐 객체가 아닌 객체의 참조가 복사됩니다.\n\n그리고 복사된 참조를 이용한 모든 작업(프로퍼티 추가·삭제 등)은 동일한 객체를 대상으로 이뤄집니다.\n\n<br>\n\n객체의 \'진짜 복사본’을 만들려면 \'얕은 복사(shallow copy)\'를 가능하게 해주는 `Object.assign`이나 \'깊은 복사’를 가능하게 해주는 [_.cloneDeep(obj)](https://lodash.com/docs#cloneDeep)를 사용하면 됩니다. \n\n이때 얕은 복사본은 중첩 객체를 처리하지 못한다는 점을 기억해 두시기 바랍니다.'),
(16,'JavaScript','Garbage Collection','## 📘 Garbage Collection\n\n자바스크립트는 눈에 보이지 않는 곳에서 메모리 관리를 수행합니다.\n\n원시값, 객체, 함수 등 우리가 만드는 모든 것은 메모리를 차지합니다.\n\n그렇다면 더는 쓸모 없어지게 된 것들은 어떻게 처리될까요?\n\n지금부턴 자바스크립트 엔진이 어떻게 필요 없는 것을 찾아내 삭제하는지 알아보겠습니다.\n\n<br>\n\n자바스크립트는 _도달 가능성(reachability)_ 이라는 개념을 사용해 메모리 관리를 수행합니다.\n\n‘도달 가능한(reachable)’ 값은 쉽게 말해 어떻게든 접근하거나 사용할 수 있는 값을 의미합니다.\n\n도달 가능한 값은 메모리에서 삭제되지 않습니다.\n\n<br>\n\n아래 소개해 드릴값들은 그 태생부터 도달 가능하기 때문에, 명백한 이유 없이는 삭제되지 않습니다.\n\n-   현재 함수의 지역 변수와 매개변수\n-   중첩 함수의 체인에 있는 함수에서 사용되는 변수와 매개변수\n-   전역 변수\n-   기타 등등\n\n이런 값은 root 라고 불립니다.\n\n<br>\n\n루트가 참조하는 값이나 체이닝으로 루트에서 참조할 수 있는 값은 도달 가능한 값이 됩니다.\n\n전역 변수에 객체가 저장되어있다고 가정해 봅시다.\n\n이 객체의 프로퍼티가 또 다른 객체를 참조하고 있다면, 프로퍼티가 참조하는 객체는 도달 가능한 값이 됩니다.\n\n이 객체가 참조하는 다른 모든 것들도 도달 가능하다고 여겨집니다. 자세한 예시는 아래에서 살펴보겠습니다.\n\n---\n## 📘 UnReachable Property\n\n아주 간단한 예시를 들어보겠습니다.\n\n```javascript\nlet user = {\n    name: \"Kim\"\n};\n\nuser = null; // Kim = Unreachable\n```\n\n<br>\n\n전역 변수인 user는 `name: \"Kim\"` 이라는 객체를 참조합니다.\n\nKim의 프로퍼티 name은 원시값을 저장하고 있기 때문에 객체 안에 표현했습니다.\n\nuser 변수를 선언할 시점엔 Kim에 도달할 수 있었지만  user 변수에 null을 할당하면서 참조도 사라집니다.\n\n참조가 사라졌으니 `Kim`에 도달할 수 있는 방법이 없기 때문에 Garbage Collection의 제거 대상이 됩니다.\n\n그럼 이제 Garbage Collection이 Kim에 저장된 데이터를 삭제하고 메모리에서도 삭제합니다.\n\n<br>\n\n**참조가 2개인 객체의 Garbage Collection 제거 대상**\n\n```javascript\nlet user = {\n   name: \"Kim\"\n};\n\nlet admin = user;\nuser = null;\n```\n\n전역 변수 `admin`을 통하면 여전히 객체 John에 접근할 수 있기 때문에 John은 메모리에서 삭제되지 않습니다.\n\n이 상태에서 `admin`을 다른 값(null 등)으로 덮어쓰면 John은 메모리에서 삭제될 수 있습니다.\n\n<br>\n\n**연결된 객체**\n\n이제 가족관계를 나타내는 예시를 보겠습니다.\n\n```javascript\nfunction marry(man, woman) {\n   woman.husband = man;\n  man.wift = woman;\n\n   return {\n              father: man,\n          mother: woman\n }\n}\n\nlet family = marry(\n   { name: \"Kim\" },\n    { name: \"Lee\" }\n);\n\ndelete family.father;\ndelete family.mother.husband;\n```\n\n함수 `marry`(결혼하다)는 매개변수로 받은 두 객체를 서로 참조하게 하면서 \'결혼’시키고, 두 객체를 포함하는 새로운 객체를 반환합니다.\n\n<br>\n\n삭제한 2개의 참조 중 하나만 지웠다면 모든 객체가 여전히 도달 가능한 상태였을 겁니다.\n\n하지만 참조 2개를 다 지우면 Kim으로 들어오는 참조가 모두 사라져 Unreachable 상태가 됩니다.\n\n위 코드에선 2개의 참조를 모두 다 지웠기 떄문에 Garbage Collection의 대상이 되고 남은건 family.mother 이 됩니다.\n\n---\n## 📘 Garbage Collector 내부 알고리즘\n\n\'mark-and-sweep’이라 불리는 가비지 컬렉션 기본 알고리즘에 대해 알아봅시다.\n\n\'가비지 컬렉션’은 대개 다음 단계를 거쳐 수행됩니다.\n\n-   가비지 컬렉터는 루트(root) 정보를 수집하고 이를 ‘mark(기억)’ 합니다.\n-   루트가 참조하고 있는 모든 객체를 방문하고 이것들을 ‘mark’ 합니다.\n-   mark 된 모든 객체에 방문하고 _그 객체들이_ 참조하는 객체도 mark 합니다.\n-  한번 방문한 객체는 전부 mark 하기 때문에 같은 객체를 다시 방문하는 일은 없습니다.\n-   루트에서 도달 가능한 모든 객체를 방문할 때까지 위 과정을 반복합니다.\n-   mark 되지 않은 모든 객체를 메모리에서 삭제합니다.\n\n---\n## 📘 요약\n\n-   가비지 컬렉션은 엔진이 자동으로 수행하므로 개발자는 이를 억지로 실행하거나 막을 수 없습니다.\n-   객체는 도달 가능한 상태일 때 메모리에 남습니다.\n-   참조된다고 해서 도달 가능한 것은 아닙니다. 서로 연결된 객체들도 도달 불가능할 수 있습니다.\n\n<br>\n\n모던 자바스크립트 엔진은 좀 더 발전된 가비지 컬렉션 알고리즘을 사용합니다.\n\n어떤 알고리즘을 사용하는지 궁금하다면 ‘The Garbage Collection Handbook: The Art of Automatic Memory Management’(저자 – R. Jones et al)를 참고하시기 바랍니다.\n\n저수준(low-level) 프로그래밍에 익숙하다면, [A tour of V8: Garbage Collection](http://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection)을 읽어보세요. V8 가비지 컬렉터에 대한 자세한 내용을 확인해 볼 수 있습니다.'),
(17,'JavaScript','Function & This','## 📘 Function & This\n\n객체는 사용자(user), 주문(order) 등과 같이 실제 존재하는 개체(entity)를 표현하고자 할 때 생성됩니다.\n\n```javascript\nlet user = {\n      name: \"Kim\",\n        age: 30\n};\n```\n\n사용자는 현실에서 장바구니에서 물건 선택하기, 로그인하기, 로그아웃하기 등의 행동을 합니다. 이와 마찬가지로 사용자를 나타내는 객체 user도 특정한 _행동_을 할 수 있습니다.\n\n자바스크립트에선 객체의 프로퍼티에 함수를 할당해 객체에게 행동할 수 있는 능력을 부여해줍니다.\n\n<br>\n\n>  **함수 생성**\n\n객체 `user`에게 인사할 수 있는 능력을 부여해 줍시다.\n\n```javascript\nlet user = {\n      name: \"Kim\",\n        age: 30\n};\n\nuser.sayHi = function() {\n      alert(\"안녕하세요\");\n};\n\nuser.sayHi();\n```\n\n함수 표현식으로 함수를 만들고, 객체 프로퍼티 `user.sayHi`에 함수를 할당해 주었습니다.\n\n이제 객체에 할당된 함수를 호출하면 user가 인사를 해줍니다.\n\n이렇게 객체 프로퍼티에 할당된 함수를 _메서드(method)_ 라고 부릅니다.\n\n위 예시에선 `user`에 할당된 `sayHi`가 메서드이죠.\n\n<br>\n\n\n>  **함수는 아래와 같이 이미 정의된 함수를 이용해서 만들 수도 있습니다.**\n\n```javascript\nlet user = {...};\n\nfunction sayHi() {\n alert(안녕하세요);\n};\n\n// 만들어진 함수를 user의 프로퍼티로 할당\nuser.sayHi = sayHi;\n\nuser.sayHi();\n```\n\n<br>\n\n>  **함수 단축 구문**\n\n객체 리터럴 안에 함수를 선언할 때 사용할 수 이는 단축 문법입니다.\n\nfunction을 생략해도 함수를 정의할 수 있습니다.\n\n```javascript\n// 단축 X\nuser = {\n  sayHi: function() {\n           alert(\"Hello\");\n     }\n};\n\n// 단축\nuser = {\n    sayHi() {\n             alert(\"Hello\");\n     }\n};\n```\n\n---\n## 📘 Function과 this\n\n메서드는 객체에 저장된 정보에 접근할 수 있어야 제 역할을 할 수 있습니다.\n\n모든 메서드가 그런 건 아니지만, 대부분의 메서드가 객체 프로퍼티의 값을 활용합니다.\n\n`user.sayHi()`의 내부 코드에서 객체 `user`에 저장된 이름(name)을 이용해 인사말을 만드는 경우가 이런 경우에 속합니다.\n\n<br>\n\n**메서드 내부에서 `this` 키워드를 사용하면 객체에 접근할 수 있습니다.**\n\n이때 \'점 앞’의 `this`는 객체를 나타냅니다. 정확히는 메서드를 호출할 때 사용된 객체를 나타내죠.\n\n이미 자바,코틀린 등을 배울때 알고 있는 내용이기 때문에 기본적인 사용법은 생략합니다.\n\n<br>\n\n다만 자바스크립트의 this는 다른 프로그래밍 언어들과는 동작방식이 조금 다릅니다.\n\n자바스크립트에선 모든 함수에 this를 사용할 수 있습니다.\n\n아래와 같이 코드를 작성해도 Syntax Error가 발생하지 않습니다.\n\n```javascript\nfunction sayHi() {\n       alert(this.name);\n}\n```\n\n<br>\n\n왜냐하면 자바스크립트에서 `this`의 값은 런타임 시 결정됩니다. 컨텍스트에 따라 달라지죠.\n\n동일한 함수라도 다른 객체에서 호출했다면 `this`가 참조하는 값이 달라집니다.\n\n```javascript\nlet user = { name: \"Kim\" };\nlet admin = { name: \"Admin\" };\n\nfunction sayHi() {\n   alert(this.name);\n}\n\n// 각각의 객체에서 동일한 함수 사용\nuser.f = sayHi();\nadmin.f = sayHi();\n\n// this는 \'.\' 앞의 객체를 참조하기 때문에 this의 값이 각각 달라짐\nuser.f(); // Kim, this == user\nadmin.f(); // Admin, this == admin\n\nadmin[\'f\'](); // Admin, 점과 대괄호는 동일하게 동작함\n```\n\n<br>\n\n규칙은 간단합니다.\n\n`obj.f()`를 호출했다면 this는 f를 호출하는동안의 `obj`입니다.\n\n<br>\n\n### 객체 없이 호출하기 this == undefined\n\n객체가 없어도 함수를 호출할 수 있습니다.\n\n```javascript\nfunction sayHi() {\n    alert(this);\n}\n\nsayHi(); // undefined\n```\n\n위와 같은 코드를 엄격 모드에서 실행하면, `this`엔 `undefined`가 할당됩니다. `this.name`으로 name에 접근하려고 하면 에러가 발생하죠.\n\n그런데 엄격 모드가 아닐 때는 `this`가 _전역 객체_를 참조합니다.\n\n<br>\n\n브라우저 환경에선 `window`라는 전역 객체를 참조하죠. 이런 동작 차이는 `\"use strict\"`가 도입된 배경이기도 합니다.\n\n이런 식의 코드는 대개 실수로 작성된 경우가 많습니다. 함수 본문에 `this`가 사용되었다면, 객체 컨텍스트 내에서 함수를 호출할 것이라고 예상하시면 됩니다.\n\n<br>\n\n### 자유로운 this가 만드는 결과\n\n다른 언어를 사용하다 자바스크립트로 넘어온 개발자는 `this`를 혼동하기 쉽습니다.\n\n`this`는 항상 메서드가 정의된 객체를 참조할 것이라고 착각하죠. 이런 개념을 \'bound `this`\'라고 합니다.\n\n<br>\n\n자바스크립트에서 `this`는 런타임에 결정됩니다.\n\n메서드가 어디서 정의되었는지에 상관없이 `this`는 ‘점 앞의’ 객체가 무엇인가에 따라 ‘자유롭게’ 결정됩니다.\n\n<br>\n\n이렇게 `this`가 런타임에 결정되면 좋은 점도 있고 나쁜 점도 있습니다.\n\n함수(메서드)를 하나만 만들어 여러 객체에서 재사용할 수 있다는 것은 장점이지만, 이런 유연함이 실수로 이어질 수 있다는 것은 단점입니다.\n\n<br>\n\n자바스크립트가 `this`를 다루는 방식이 좋은지, 나쁜지는 우리가 판단할 문제가 아닙니다.\n\n개발자는 `this`의 동작 방식을 충분히 이해하고 장점을 취하면서 실수를 피하는 데만 집중하면 됩니다.\n\n<br>\n\n### this가 없는 Arrow Function\n\n화살표 함수는 일반 함수와는 달리 ‘고유한’ `this`를 가지지 않습니다.\n\n화살표 함수에서 `this`를 참조하면, 화살표 함수가 아닌 ‘평범한’ 외부 함수에서 `this` 값을 가져옵니다.\n\n아래 예시에서 함수 `arrow()`의 `this`는 외부 함수 `user.sayHi()`의 `this`가 됩니다.\n\n```javascript\nlet user = {\n  firstName = \"구름\";\n sayHi() {\n             let arrow = () => alert(this.firstName);\n              arrow();\n      }\n};\n\nuser.sayHi(); // 구름\n```\n\n별개의 `this`가 만들어지는 건 원하지 않고, 외부 컨텍스트에 있는 `this`를 이용하고 싶은 경우 화살표 함수가 유용합니다.\n\n<br>\n\n###  간단한 예시\n\n`calculator`라는 객체를 만들고 세 메서드를 구현해 봅시다.\n\n- `read()`에선 프롬프트 창을 띄우고 더할 값 두 개를 입력받습니다. 입력받은 값은 객체의 프로퍼티에 저장합니다.\n- `sum()`은 저장된 두 값의 합을 반환합니다.\n- `mul()`은 저장된 두 값의 곱을 반환합니다.\n\n```javascript\nlet calculator = {\n       sum() { return this.a + this.b },\n      mul() { return this.a * this.b },\n     read() {\n              this.a = +prompt(\"첫번째 값: \", 0);\n         this.b = +prompt(\"두번째 값: \", 0);\n }\n};\n\ncalculator.read();\nalert(calculator.sum());\nalert(claculator.mul());\n```\n\n<br>\n\n'),
(18,'JavaScript','new 연산자 & 생성자 함수','## 📘 new 연산자 & 생성자 함수\n\n객체 리터럴 `{...}` 을 사용하면 객체를 쉽게 만들 수 있습니다. \n\n그런데 개발을 하다 보면 유사한 객체를 여러 개 만들어야 할 때가 생기곤 합니다. \n\n복수의 사용자, 메뉴 내 다양한 아이템을 객체로 표현하려고 하는 경우가 그렇죠.\n\n`\'new\'` 연산자와 생성자 함수를 사용하면 유사한 객체 여러 개를 쉽게 만들 수 있습니다.\n\n---\n## 📘  생성자 함수\n\n생성자 함수(constructor function)와 일반 함수에 기술적인 차이는 없습니다. 다만 생성자 함수는 아래 두 관례를 따릅니다.\n\n1. 함수 이름의 첫 글자는 대문자로 시작합니다.\n2. 반드시 `\'new\'` 연산자를 붙여 실행합니다.\n\n```javascript\nfunction User(name) {\n   // this = {}; (빈 객체가 암시적으로 만들어짐)\n this.name = name;\n     this.isAdmin = false;\n // return this; (this가 암시적으로 반환됨)\n}\n\nlet user = new User(\"구름\");\n\nalerrt(user.name);\nalert(user.isAdmin);\n```\n\n<br>\n\n> **익명 생성자 함수**\n\n재사용할 필요가 없는 복잡한 객체를 만들어야 한다고 해봅시다. 많은 양의 코드가 필요할 겁니다. \n\n이럴 땐 아래와 같이 코드를 익명 생성자 함수로 감싸주는 방식을 사용할 수 있습니다.\n\n```javascript\nlet user = new function() {\n       this.name = \"Kim\";\n  this.isAdmin = false;\n}\n```\n\n위 생성자 함수는 익명 함수이기 때문에 어디에도 저장되지 않습니다. \n\n처음 만들 때부터 단 한 번만 호출할 목적으로 만들었기 때문에 재사용이 불가능합니다. \n\n이렇게 익명 생성자 함수를 이용하면 재사용은 막으면서 코드를 캡슐화 할 수 있습니다.\n\n---\n## 📘  new.target & 생성자 함수\n\n일반적으로 잘 쓰이지 않는 new.target입니다.\n\n`new.target` 프로퍼티를 사용하면 함수가 `new`와 함께 호출되었는지 아닌지를 알 수 있습니다.\n\n일반적인 방법으로 함수를 호출했다면 `new.target`은 undefined를 반환합니다. 반면 `new`와 함께 호출한 경우엔 `new.target`은 함수 자체를 반환해줍니다.\n\n```javascript\nfunction User() {\n   alert(new.target);\n}\n\nUser(); // undefined\nnew User(); // function User {...}\n```\n\n함수 본문에서 `new.target`을 사용하면 해당 함수가 `new`와 함께 호출되었는지(in constructor mode) 아닌지(in regular mode)를 확인할 수 있습니다.\n\n이를 활용해 일반적인 방법으로 함수를 호출해도 `new`를 붙여 호출한 것과 같이 동작하도록 만들어보겠습니다.\n\n```javascript\nfunction User(name) {\n  // new 없이 호출해도 new를 이용해 생성해준다.\n if (!new.target) {\n            return new User(name);\n        }\n     this.name = name;\n}\n\nlet cloud = User(\"구름\"); // new를 안써도 new를 쓴것처럼 바꿔줍니다.\nalert(cloud.name); // 구름\n```\n\n그런데 이 방법을 믿고 객체를 만드는 경우에도 `new`를 생략하면 코드가 정확히 무슨 일을 하는지 알기 어렵습니다. \n\n`new`가 붙어있으면 새로운 객체를 만든다는 걸 누구나 알 수 있기 때문에 \n\n`new`를 생략해서 객체를 만드는것은 정말 필요한 경우에만 사용하시고 남발하지 않으시길 바랍니다.\n\n---\n## 📘  생성자 & Return\n\n생성자 함수엔 보통 `return` 문이 없습니다. \n\n반환해야 할 것들은 모두 `this`에 저장되고, `this`는 자동으로 반환되기 때문에 반환문을 명시적으로 써 줄 필요가 없습니다.\n\n그런데 만약 `return` 문이 있다면 어떤 일이 벌어질까요? 아래와 같은 간단한 규칙이 적용됩니다.\n\n- 객체를 `return` 한다면 `this` 대신 객체가 반환됩니다.\n- 원시형을 `return` 한다면 `return`문이 무시됩니다.\n\n`return` 뒤에 객체가 오면 생성자 함수는 해당 객체를 반환해주고, 이 외의 경우는 `this`가 반환되죠.\n\n아래 예시에선 첫 번째 규칙이 적용돼 `return`은 `this`를 무시하고 객체를 반환합니다\n\n```javascript\nfunction BigUser() {\n    this.name = \"원숭아\";\n       return { name: \"토끼\" }; // this가 아닌 새로운 객체를 반환함\n}\n\nalert(new BigUser().name); // 토끼\n```\n\n아무것도 `return`하지 않는 예시를 살펴봅시다. 원시형을 반환하는 경우와 마찬가지로 두 번째 규칙이 적용됩니다.\n\n```javascript\nfunction SmallUser() {\n this.name = \"원숭이\";\n       return; // this를 반환함\n}\n\nalert(new SmallUser().name); // 원숭이\n```\n\n<br>\n\n**괄호 생략가능**\n\n\'좋은 스타일\'은 아니지만 파라미터가 없는 생성자 함수는 괄호를 생략해 호출할 수 있습니다.\n\n```javascript\n// 2개 모두 동일하게 동작함\nlet user = new User;\nlet user = new User();\n```\n\n---\n## 📘 생성자 내부 함수\n\n생성자 함수를 사용하면 매개변수를 이용해 객체 내부를 자유롭게 구성할 수 있습니다. 엄청난 유연성이 확보되죠.\n\n지금까진 `this`에 프로퍼티를 더해주는 예시만 살펴봤는데, 메서드를 더해주는 것도 가능합니다.\n\n아래 예시에서 `new User(name)`는 프로퍼티 `name`과 메서드 `sayHi`를 가진 객체를 만들어줍니다.\n\n```javascript\nfunction User(name) {\n  this.name = name;\n     this.sayHi = function() {\n             alert(\"제 이름은 \" + this.name + \"입니다.\");\n      };\n}\n\nlet cloud = new User(\"구름\");\n\ncloud.sayHi();\n```\n\n---\n## 📘  요약\n\n- 생성자 함수(짧게 줄여서 생성자)는 일반 함수입니다. 다만, 일반 함수와 구분하기 위해 함수 이름 첫 글자를 대문자로 씁니다.\n- 생성자 함수는 반드시 `new` 연산자와 함께 호출해야 합니다. `new`와 함께 호출하면 내부에서 `this`가 암시적으로 만들어지고, 마지막엔 `this`가 반환됩니다.\n\n<br>\n\n생성자 함수는 유사한 객체를 여러 개 만들 때 유용합니다.\n\n자바스크립트는 언어 차원에서 다양한 생성자 함수를 제공합니다. \n\n날짜를 나타내는 데 쓰이는 `Date`, 집합(set)을 나타내는 데 쓰이는 `Set` 등의 내장 객체는 \n\n이런 생성자 함수를 이용해 만들 수 있습니다.\n\n---\n## 📘  연습\n\n### 계산기 만들기\n\n아래와 같은 세 개의 메서드를 가진 생성자 함수, `Calculator`를 만들어보세요.\n\n- `read()` – `prompt` 함수를 이용해 사용자로부터 값 두 개를 받고, 이를 객체 프로퍼티에 저장합니다.\n- `sum()` – 프로퍼티에 저장된 값 두 개를 더한 후 반환합니다.\n- `mul()` – 프로퍼티에 저장된 값 두 개를 곱한 후 반환합니다.\n\n```javascript\nfunction Calculator() {\n    this.sum = function() {\n               return this.a + this.b;\n       };\n    \n      this.mul = function() {\n               return this.a * this.b;\n       };\n    \n      this.read = function() {\n              this.a = +prompt(\"첫번쨰 숫자\", 0);\n        this.b = +prompt(\"두번째 숫자\", 0);\n  };\n}\n\nlet calculator = new Claculator();\nclaculator.read();\n\nalert(\"SUM = \" + calculator.sum());\nalert(\"MUL = \" + calculator.mul());\n```\n\n<br>\n\n### 누산기 만들기\n\n생성자 함수 `Accumulator(startingValue)`를 만들어 보세요.\n\n`Accumulator(startingValue)`를 이용해 만드는 객체는 아래와 같은 요건을 충족해야 합니다.\n\n- 프로퍼티 `value`에 현재 값(current value)을 저장합니다. 최초 호출 시엔 생성자 함수의 인수, `startingValue`에서 시작값(starting value)을 받아옵니다.\n- 메서드 `read()`에선 `prompt` 함수를 사용해 사용자로부터 숫자를 받아오고, 받은 숫자를 `value`에 더해줍니다.\n\n프로퍼티 `value`엔 `startingValue`와 사용자가 입력한 모든 값의 총합이 더해져 저장됩니다.\n\n```javascript\nfunction Accumulator(startingValue) {\n this.value = startingValue;\n\n this.read = function() {\n              this.value += +prompt(\"숫자\", 0);\n   };\n}\n\nlet accumulator = new Accumulator(1);\naccumulator.read();\naccumulator.read();\nalert(accumulator.value);\n```'),
(19,'JavaScript','Optional Channing','## 📘 Optional Chaining\n\n옵셔널 체이닝(optional chaining) `?.`을 사용하면 프로퍼티가 없는 중첩 객체를 에러 없이 안전하게 접근할 수 있습니다.\n\n<br>\n\n> **Optional Chaning이 필요한 이유**\n\n이제 막 자바스크립트를 배우기 시작했다면 옵셔널 체이닝이 등장하게 된 배경 상황을 직접 겪어보지 않았을 겁니다. \n\n몇 가지 사례를 재현하면서 왜 옵셔널 체이닝이 등장했는지 알아봅시다.\n\n사용자가 여러 명 있는데 그중 몇 명은 주소 정보를 가지고 있지 않다고 가정해봅시다. \n\n이럴 때 `user.address.street`를 사용해 주소 정보에 접근하면 에러가 발생할 수 있습니다.\n\n```javascript\nlet user = {}; // 주소 정보가 없는 사용자\nalert(user.address.street); // TypeError: Cannot read property \'street\' of undefined\n```\n\n<br>\n\n또 다른 사례론 브라우저에서 동작하는 코드를 개발할 때 발생할 수 있는 문제가 있습니다. \n\n자바스크립트를 사용해 페이지에 존재하지 않는 요소에 접근해 요소의 정보를 가져오려 하면 문제가 발생하죠.\n\n```javascript\n// querySeclector(...) 호출 결과가 null인 경우 에러 발생\nlet html = document.querySeletor(\'.my-element\').innerHTML;\n```\n\n<br>\n\n명세서에 `?.`이 추가되기 전엔 이런 문제들을 해결하기 위해 `&&` 연산자를 사용하곤 했습니다.\n\n```javascript\nlet user = {};\n// undefined, 에러가 발생하지 않음\nalert(user && user.address && user.address.street);\n```\n\n중첩 객체의 특정 프로퍼티에 접근하기 위해 거쳐야 할 구성요소들을 AND로 연결해 \n\n실제 해당 객체나 프로퍼티가 있는지 확인하는 방법을 사용했었죠. \n\n그런데 이렇게 AND를 연결해서 사용하면 코드가 아주 길어진다는 단점이 있습니다.\n\n---\n## 📘 Optional Chaining의 등장\n\n`?.`은 `?.`\'앞’의 평가 대상이 `undefined`나 `null`이면 평가를 멈추고 `undefined`를 반환합니다.\n\nKotlin의 Null처리 연산자인 `?`과 거의 같습니다.\n\n**설명이 장황해지지 않도록 지금부턴 평가후 결과가 `null`이나 `undefined`가 아닌 경우엔 값이 ‘있다’ 혹은 \'존재한다’라고 표현하겠습니다.**\n\n이제 옵셔널 체이닝을 사용해 `user.address.street`에 안전하게 접근해봅시다.\n\n```javascript\nlet user = {};\nalert(user?.address?.street); // undefined, 에러가 발생하지 않음\n```\n\n<br>\n\n`user?.address`로 주소를 읽으면 아래와 같이 `user` 객체가 존재하지 않더라도 에러가 발생하지 않습니다.\n\n```javascript\nlet user = null;\n\nalert(user?.address); // undefined\nalert(user?.adddress.street); // undefined\n```\n\n위 예시에서 사용된 `user?.`는 `user`가 `null`이나 `undefined`인 경우만 처리할 수 있습니다.\n\n`user`가 `null`이나 `undefined`가 아니고 실제 값이 존재하는 경우엔 반드시 `user.address` 프로퍼티는 있어야 합니다. \n\n그렇지 않으면 `user?.address.street`의 두 번째 점 연산자에서 에러가 발생합니다.\n\n---\n## 📘 단락 평가\n\n`?.`는 왼쪽 평가대상에 값이 없으면 즉시 평가를 멈춥니다. \n\n참고로 이런 평가 방법을 단락 평가(short-circuit)라고 부릅니다.\n\n그렇기 때문에 함수 호출을 비롯한 `?.` 오른쪽에 있는 부가 동작은 `?.`의 평가가 멈췄을 때 더는 일어나지 않습니다.\n\n```javascript\nlet user = null;\nlet x = 0;\n\nuser?.sayHi(x++); // 아무 일도 일어나지 않습니다.\n\nalert(x); // 0, x는 증가하지 않습니다.\n```\n\n---\n## 📘 `?.()와 ?.[]`\n\n`?.`은 연산자가 아닙니다. \n\n`?.`은 함수나 대괄호와 함께 동작하는 특별한 문법 구조체(syntax construct)입니다.\n\n함수 관련 예시와 함께 존재 여부가 확실치 않은 함수를 호출할 때 `?.()`를 어떻게 쓸 수 있는지 알아봅시다.\n\n한 객체엔 메서드 `admin`이 있지만 다른 객체엔 없는 상황입니다.\n\n```javascript\nlet user1 = {\n      admin() {\n             alert(\"관리자\");\n    }\n}\n\nlet user2 = {};\n\nuser1.admin?.(); // 관리자\nuser2.admin?.();\n```\n\n두 상황 모두에서 user 객체는 존재하기 때문에 `admin` 프로퍼티는 `.`만 사용해 접근했습니다.\n\n그리고 난 후 `?.()`를 사용해 `admin`의 존재 여부를 확인했습니다. \n\n<br>\n\n`user1`엔 `admin`이 정의되어 있기 때문에 메서드가 제대로 호출되었습니다. \n\n반면 `user2`엔 `admin`이 정의되어 있지 않았음에도 불구하고 메서드를 호출하면 에러 없이 그냥 평가가 멈추는 것을 확인할 수 있습니다.\n\n<br>\n\n`.`대신 대괄호 `[]`를 사용해 객체 프로퍼티에 접근하는 경우엔 `?.[]`를 사용할 수도 있습니다. \n\n위 예시와 마찬가지로 `?.[]`를 사용하면 객체 존재 여부가 확실치 않은 경우에도 안전하게 프로퍼티를 읽을 수 있습니다.\n\n```javascript\nlet user1 = {\n      firsName: \"abc\"\n};\n\nlet user2 = null; // user2는 권한이 없는 사용자라고 가정합니다.\n\nalert(user1?.[key]); // abc\nalert(user2?.[key]); // undefined\n\nalert(user1?.[key].somethins?.not?.existing); // undefined\n```\n\n<br>\n\n`?.`은 `delete`와 조합해 사용할 수도 있습니다.\n\n```javascript\ndelete user?.name; // user가 존재하면 user.name을 삭제합니다.\n```\n\n<br>\n\n> `?.` 은 읽기나 삭제하기에는 사용할 수 있지만 쓰기에는 사용할 수 없습니다.\n\n```javascript\n// user가 존재할 경우 user.name에 값을 쓰려는 의도로 아래와 같이 코드를 작성해 보았습니다. \nuser?.name = \"Violet\";\n\n// SyntaxError: Invalid left-hand side in assignment\n// 에러가 발생하는 이유는 undefined = \"Violet\"이 되기 때문입니다.\n```'),
(20,'Assignment','변수와 자료형','## 📘 변수와 자료형 - 2024.02.05\n\n<br>\n\n### 👨‍💻 1번 문제 - 두 변수 a,b의 값을 바꿔서 출력하기\n\n<details>\n<summary>펼치기</summary>\n\n<br>\n\n### 풀이\n\n```js\nlet a = 1\nlet b = 2;\nconsole.log(a, b)\n\na = a ^ b // 0001 XOR 0010 = 0011 (값 : 3)\nb = a ^ b // 0011 XOR 0010 = 0001 (값 : 1)\na = a ^ b// 0011 XOR 0001 = 0010 (값 : 2)\nconsole.log(a, b)\n```\n\n<br>\n\n### 풀이 방법\n\n- XOR 비트 연산은 두 비트가 다르면 1, 같으면 0을 반환합니다.\n- 위 연산을 하나씩 풀어보면,\n- `a = a ^ b` = 0001, 0010 을 비트연산하면 0011이 되어 처음 a = a ^ b의 값은 3(0011) 이 됩니다.\n- `b = a ^ b` = 0010, 0011 을 비트연산하면 0001로 b의 값은 1이 됩니다.\n- `a = a ^ b` = 0011, 0001 을 비트연산하면 0010으로 다시 2가 됩니다.\n\n</details>\n\n---\n\n### 👨‍💻 2번 문제 - 각종 연산식 출력\n\n<details>\n<summary>펼치기</summary>\n\n<br>\n\n### 풀이\n\n```js\nconsole.log(\'========== 산술 연산자 ==========\')\nconsole.log(`20 + 30 = ${20 + 30}`)\nconsole.log(`\"20\" + \"30\" = ${\"20\" + \"30\"}`)\nconsole.log(`\"Hello + \"\" + 2021 = ${\"Hello\" + \"\" + 2021}`)\nconsole.log(`1 + 2 * 3 = ${1 + 2 * 3}`)\nconsole.log(`(1 + 3) ** 2 = ${(1 + 3) ** 2}`)\nconsole.log(`1 / 0 = ${1 / 0}`)\nconsole.log(`6 % 2 = ${6 % 2}`)\nconsole.log(`7.5 % 2 = ${7.5 % 2}`)\n\nconsole.log(\'\\n\')\n\nconsole.log(\'========== 동등성 & 동일성 ==========\')\nconsole.log(`5 == 5 = ${5 == 5}`)\nconsole.log(`5 === 5 = ${5 === 5}`)\nconsole.log(`5 == \"5\" = ${5 == \"5\"}`)\nconsole.log(`5 === \"5\" = ${5 === \"5\"}`)\n\nconsole.log(\'\\n\')\n\nconsole.log(\'========== 논리 연산자 (Boolean) ==========\')\nconsole.log(`5 != 5.0 = ${5 != 5.0}`)\nconsole.log(`5 !== 5.0 = ${5 !== 5.0}`)\nconsole.log(`\"true\" === true = ${\"true\" === true}`)\nconsole.log(`5 <= 5.0 = ${5 <= 5.0}`)\nconsole.log(`5 >= 5 = ${5 >= 5}`)\nconsole.log(`true || true = ${true || true}`)\nconsole.log(`true || false = ${true || false}`)\nconsole.log(`true && true = ${true && true}`)\nconsole.log(`true && false = ${true && false}`)\nconsole.log(`!true = ${!true}`)\nconsole.log(`!false = ${!false}`)\n```\n\n<br>\n\n### 출력값\n\n```js\n/* ========== 산술 연산자 ========== */\n20 + 30 = 50\n\"20\" + \"30\" = 2030\n\"Hello + \"\" + 2021 = Hello2021\n1 + 2 * 3 = 7\n(1 + 3) ** 2 = 16\n1 / 0 = Infinity\n6 % 2 = 0\n7.5 % 2 = 1.5\n\n\n/* ========== 동등성 & 동일성 ========== */\n5 == 5 = true\n5 === 5 = true\n5 == \"5\" = true\n5 === \"5\" = false\n\n\n/* ========== 논리 연산자 (Boolean) ========== */\n5 != 5.0 = false\n5 !== 5.0 = false\n\"true\" === true = false\n5 <= 5.0 = true\n5 >= 5 = true\ntrue || true = true\ntrue || false = true\ntrue && true = true\ntrue && false = false\n!true = false\n!false = true\n```\n\n<br>\n\n> **동등성 & 동일성 이란?**\n\n**== 연산 (동등성)**\n\n- 연산은 단순히 피연산자의 **값**이 같은지만 확인합니다.\n- 만약 타입이 다른 5 와 \"5\"를 연산하면 두 연산자를 내부적으로 같은 Type으로 변환 후 비교를 수행합니다.\n- 그래서 5 == \"5\"는 내부적으로 문자열 5를 숫자 5로 타입 변환을 수행하기 때문에 5 == 5 같은 값에 대해 True가 나오게 됩니다.\n \n<br>\n\n**=== 연산 (동일성)**\n- 이 연산은 피연산자의 값과 Type이 모두 같은지 엄격하게 비교하고, 타입이 다르면 False를 반환하며, 내부적으로 타입 변환을 하지 않습니다.\n- 그래서 5 === \"5\" 는 타입이 string과 number로 다르기 때문에 False가 반환됩니다.\n\n</details>');
/*!40000 ALTER TABLE `note` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `user`
--

DROP TABLE IF EXISTS `user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `user` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `created_at` varchar(255) DEFAULT NULL,
  `modified_at` varchar(255) DEFAULT NULL,
  `name` varchar(255) NOT NULL,
  `password` varchar(255) NOT NULL,
  `type` enum('유저','개발자') DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `UK_gj2fy3dcix7ph7k8684gka40c` (`name`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `user`
--

LOCK TABLES `user` WRITE;
/*!40000 ALTER TABLE `user` DISABLE KEYS */;
INSERT INTO `user` VALUES
(1,'2024-02-06 02시 14분 52초','','신건우','$2a$10$ZP820xlBoRVHcwbrx1rCjOjsf80k/o5dfMuaVnfTHL.NO5JL4MmwO','개발자');
/*!40000 ALTER TABLE `user` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2024-02-06  2:33:45
